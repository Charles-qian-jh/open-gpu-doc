<?xml-stylesheet type="text/xsl" href="devinit.xsl"?>
<devinit_spec>

    <!--
    ******************************************************************
    ******************************************************************
    THIS IS THE OFFICIAL DEVINIT OPCODE SPECIFICATION.
    ALL CHANGES TO OPCODES MUST BE DOCUMENTED IN THIS FILE.
    ******************************************************************
    ******************************************************************
    -->

    <!--

    Notes
    =====

    Space savings - core5 has INIT_PLL code, remove it!

    Consistent array numbering 0 or 1 (0), N for last "sample" entry?

    -->

    <!--

    Renaming of opcodes
    ===================

    The following opcodes should really be renamed to the indicated names for consistency.
    However, the effort to do this is probably not worth the benefits, at least at this time.

    INIT_CRTC_ZM_ARRAY          -> INIT_ZM_CRTC_ARRAY
    INIT_POLL                   -> INIT_POLL_INDEX_IO
    INIT_REG_ARRAY              -> INIT_NV_REG_ARRAY
    INIT_CONDITION              -> INIT_NV_REG_CONDITION
    INIT_RESTRICT_PROG          -> INIT_NV_REG_RESTRICT_PROG
    INIT_RESTRICT_XLAT_VFIELD_* -> INIT_XLAT_VFIELD_RESTRICT_*
    INIT_ZM_REG                 -> INIT_ZM_NV_REG
    INIT_ZM_REG_STREAM          -> INIT_ZM_NV_REG_STREAM
    INIT_ZM_REG_UNCOUPLED       -> INIT_ZM_NV_REG_UNCOUPLED
    INIT_ZM_WREG                -> INIT_ZM_NV_WREG

    All cases of "RESTRICT" to "SELECT"
    A few cases that should have an added _ZM (zero mask)
    (or better yet, remove all cases of _ZM and add a "_MASK" or "_WM" (with mask) to those that have a mask)

    -->


    <topic name="Devinit Engine Description">
        <paragraph>
            The devinit system allows a GPU programming sequence to be shared by multiple entities that would otherwise not be able to execute common code.
            One of the primary uses is to initialize the GPU at boot time.
            The same sequence can be used by the VGA BIOS, the Resource Manager for secondary adapter cases, and the FCode firmware for the Apple Mac platforms.
            The devinit system also saves space because it can express many types of sequences in less space than normal x86 assembler code.
            Also, the format of the opcodes used by the devinit system are easy to parse which facilitates being able to customize sequences in an already compiled BIOS image using the BIOSMOD tool.
        </paragraph>
        <paragraph>
            The devinit system consists of scripts that contain opcodes that specify what operations a devinit engine need to perform.
            Many opcodes have parameters that specify things such as register addresses to use and data values to write to registers.
            A devinit engine parses these opcodes and performs the indicated operations.
            Each platform that uses devinit scripts needs to have its own engine (VBIOS, Resource Manager, FCODE).
        </paragraph>
    </topic>

    <topic name="Data Buffer and Stream Capability">
        <paragraph>
            Starting with core6 the devinit engine has variations of a limited subset of opcodes that get their data values from a passed in data buffer.
            In the VBIOS implementation this buffer is passed in ES:DI.
            Because ES is used, the data buffer can be located in either the code segment (CS) for fixed data or the stack segment (SS) for dynamic data.
            There will be two types of variations: one that just grabs the data in sequence and one that has offsets from the beginning of the buffer specified.
            For example there is now:
        </paragraph>

        <code>INIT_NV_REG  (the original "inline data" version)</code>
        <code>dd &lt;address&gt;</code>
        <code>dd &lt;mask&gt;</code>
        <code>dd &lt;data&gt;</code>
        <paragraph></paragraph>
        <code>INIT_NV_REG_UNCOUPLED  (data is taken from ES:[DI + &lt;data offset&gt;], DI is not changed)</code>
        <code>dd &lt;address&gt;</code>
        <code>dd &lt;mask&gt;</code>
        <code>db &lt;data offset&gt;  (notice "db", not "dd")</code>
        <paragraph></paragraph>
        <code>INIT_NV_REG_STREAM  (data is taken from next bits at ES:DI, current bit position advanced)</code>
        <code>dd &lt;address&gt;</code>
        <code>dd &lt;mask&gt;</code>
        <code>(notice no data value or offset at all)</code>
        <paragraph></paragraph>

        <paragraph>
            So for example scaler data could be in a buffer of dwords, and a sequence of INIT_ZM_REG_STREAM opcodes in a script could control where the values are written.
        </paragraph>

        <paragraph>
            With the *_UNCOUPLED opcodes the offset into the passed in data buffer is specified as a byte, which represents the byte offset into the data buffer.
            This results in a maximum offset of 255 bytes for a maximum buffer size of 256 bytes.
            The current position is not adjusted, all offsets are relative to the initial data buffer starting location (unless _STREAM opcodes have also been used).
        </paragraph>

        <paragraph>
            With the *_STREAM opcodes the devinit engine keeps track of the current bit position within the current byte.
            For opcodes with a mask each position of the mask that is a zero will result in a bit being extracted from the stream to fill that position in the data value.
            When all the bits of the current byte are used up, the devinit engine will advance to the next byte (ES:DI is incremented in the VBIOS implementation).
            All bits in the data value that correspond to bit positions in the mask that are one will be set to zero.
            This means that the bit stream is a "packed" bit stream.
            Bits are taken starting from the least significant bit of the stream byte, and shifted into the most significant bit of the constructed value and shifted to the right.
            So a mask of 0x00 (inverse is 0xFF) and a stream byte of 0x12 (assuming your starting at bit 0) would result in a data value of 0x12.
            A mask of 0x0F (inverse is 0xF0) and a stream byte of 0x12 (assuming your starting at bit 0) would result in a data value of 0x20.
        </paragraph>

        <paragraph>
            Below is an example of use of an *_STREAM opcode:
        </paragraph>

        <paragraph>
            Data Buffer Contents:
        </paragraph>

        <code>0x12 0xF4</code>
        <paragraph></paragraph>

        <paragraph>
            Devinit Script:
        </paragraph>

        <code>; This will write a 0x12 into CRTC[A0] and advance the stream 8 bits</code>
        <code>db INIT_ZM_CRTC_STREAM</code>
        <code>db 0xA0</code>
        <paragraph></paragraph>
        <code>; This opcode usage will result in an OR mask of 0x40</code>
        <code>; (the devinit engine extracts stream from the least significant bit),</code>
        <code>; and will advance the stream by 4 bits</code>
        <code>; (the inverse of the mask ^0x0F = 0xF0 which tells where the bits</code>
        <code>; will be and how many there are)</code>
        <code>db INIT_CRTC_STREAM</code>
        <code>db 0xA1</code>
        <code>db 0x0F</code>
        <paragraph></paragraph>
        <code>; For this operation the OR mask will be 0xC3</code>
        <code>; (comes from the "F" in 0xF4),</code>
        <code>; the stream is advanced by 4 bits</code>
        <code>db INIT_CRTC_STREAM</code>
        <code>db 0xA2</code>
        <code>db 0x3C</code>
        <paragraph></paragraph>

        <paragraph>
            It is possible to mix *_STREAM and *_UNCOUPLED opcodes.
            The *_UNCOUPLED opcodes will simply offset for the adjusted data buffer position without making any further adjustments.
            Note that the current bit position within the current byte is ignored and not changed by the *_UNCOUPLED opcodes.
            While mixing the opcodes can be useful in certain situations, great care must be taken to do it properly.
        </paragraph>
    </topic>

    <topic name="Data Buffer Selection">
        <paragraph>
            The data buffer to use when running scripts for use with *_UNCOUPLED, *_STREAM, and *_READ type opcodes (only applicable for core6 and beyond) depends on the context.
            In other words, what buffer the devinit engine needs to use depends on what type of script is being run.
        </paragraph>
        <paragraph>
            When no specific data buffer is specified for a type of script, the Resource Manager script engine shall always be called with a default read/write buffer
            that is 256 bytes in length and initialized to be filled with zeros.
            This allows scripts to read registers, perform logic operations on the value read, and then write the value back to the same or other registers.
        </paragraph>
        <paragraph>
            Currently, the only script specific data buffer defined is the data buffer for the boot devinit scripts.
            Like the default data buffer, it shall be a 256 byte read/write buffer.
            Before passing the buffer to the engine the buffer shall first be cleared to all zeros and then the first portion shall be filled with data copied from the &lt;TBD&gt; table which is pointed to by the BIT in the bios image.
            This block of fixed values will usually be pointed to by the BIOS Preservation Table so that they remain fixed between firmware upgrades (and thus simulate fuses).
        </paragraph>
    </topic>

    <topic name="Device Indexes, Display Pipe Indexes and Sub-link Indexes">
        <paragraph>
            Starting with core6 the devinit engine now has the ability to have a common script run for different display pipes (heads), different
            devices (Output Resources) or/and different sublinks.
            When the devinit engine is invoked, the device and/or display pipe to use is passed as a parameter to the engine.
            The device is often taken from the DCB entry of the device that needs to be accessed.
        </paragraph>

        <paragraph>
            To specify that a privileged register address needs to be adjusted depending on the passed in display pipe, the address to access is combined with DEVINIT_USE_DPIPE(0x80000000) using a logic OR.
            When the devinit engine sees an address with this bit set it masks out the bit and adjusts the base address to be correct for the display pipe that was specified when the engine was invoked.
            Under EVO designs, this means the passed in display pipe is multiplied by 0x800 and added to the base address.
        </paragraph>

        <paragraph>
            This example illustrates writing the pixel clock on the display pipe that was passed to the devinit engine.
        </paragraph>

        <code>; Write clock</code>
        <code>db  INIT_NV_REG</code>
        <code>dd  NV_PDISP_DSI_FLIPLOCK(0) OR DEVINIT_USE_DPIPE</code>
        <code>db  DEVINIT_OFFSET_ECX</code>
        <paragraph></paragraph>

        <paragraph>
            Note that in some scripts the concept of specifying a display pipe has no meaning.
            Such scripts shall not have any addresses that use DEVINIT_USE_DPIPE.
            The INITCHK utility will flag scripts that use DEVINIT_USE_DEVICE but have no display pipe context with an error (not yet implemented).
        </paragraph>

        <paragraph>
            To specify that a opcode needs to be adjusted depending on the passed in device, the privileged register address to access is combined with the DEVINIT_USE_DEVICE(0x40000000) using a logic OR.
            When the devinit engine sees an address with this bit set it masks out the bit and adjusts the base address to be correct for the device that was specified when the engine was invoked.
            Under EVO designs, this means the passed in device is multiplied by 0x800 and added to the base address.
        </paragraph>

        <paragraph>
            This example illustrates disconnecting the source from a DAC output resource.
            The DAC index to use is passed to the devinit engine.
        </paragraph>

        <code>; Set up the source</code>
        <code>db&#160;&#160;INIT_ZM_REG</code>
        <code>dd&#160;&#160;NV_PDISP_VGA_DAC_CONTROL OR DEVINIT_USE_DEVICE</code>
        <code>dd&#160;&#160;NV_PDISP_VGA_DAC_CONTROL_OWNER_NONE OR \\</code>
        <code>&#160;&#160;&#160;&#160;NV_PDISP_VGA_DAC_CONTROL_CRCMODE_INIT OR \\</code>
        <code>&#160;&#160;&#160;&#160;NV_PDISP_VGA_DAC_CONTROL_PROTOCOL_RGB_CRT</code>
        <paragraph></paragraph>

        <paragraph>
            Note that in some scripts the concept of specifying a device has no meaning.
            Such scripts shall not have any addresses that use DEVINIT_USE_DEVICE.
            The INITCHK utility will flag scripts that use DEVINIT_USE_DEVICE but have no device context with an error (not yet implemented).
        </paragraph>

        <paragraph>
            To specify that a opcode needs to be adjusted depending on the passed in sublink, the privileged register address to access is combined with the DEVINIT_USE_SUBLINK(0x20000000) using a logic OR,
            as it is now, when DEVINIT_USE_SUBLINK is set, we would also need DEVINIT_USE_DEVICE to be set.
            When the devinit engine sees an address with this bit set it masks out the bit and adjusts the base address to be correct for the sublink that was specified when the engine was invoked.
            Under EVO designs, this means the passed in device is multiplied by 0x80 and added to the base address.
        </paragraph>

        <paragraph>
            This example illustrates enabling power to a particular SOR and Sublink.
        </paragraph>

        <code>; Enable link power</code>
        <code>db&#160;&#160;INIT_NV_REG</code>
        <code>dd&#160;&#160;NV_PDISP_SOR_DP_LINKCTL0(0) OR DEVINIT_USE_DEVICE OR DEVINIT_USE_SUBLINK</code>
        <code>dd&#160;&#160;NOT NV_PDISP_SOR_DP_LINKCTL0_ENABLE_FIELD_MASK </code>
        <code>dd&#160;&#160;NOT NV_PDISP_SOR_DP_LINKCTL0_ENABLE_YES </code>
        <paragraph></paragraph>

        <paragraph>
            Note that in some scripts the concept of specifying a sublink has no meaning.
            Such scripts shall not have any addresses that use DEVINIT_USE_SUBLINK.
            The INITCHK utility will flag scripts that use DEVINIT_USE_SUBLINK but have no device context with an error (not yet implemented).
        </paragraph>

        <paragraph>
            The DEVINIT_USE_DPIPE, DEVINIT_USE_DEVICE and DEVINIT_USE_SUBLINK bits are in the upper nibble of the 32-bit address, so they do not conflict with the address space of privileged registers (which are constrained to 24 bits).
        </paragraph>

    </topic>

    <topic name="Device Indexes and Display Pipe Indexes for Method Opcodes">
        <paragraph>
            Similar to handling Device Indexes and Display Pipe Indexes for normal opcodes, the method opcodes (INIT_DISPLAY_METHOD*) have flags that are bitwise OR'ed with the method offset.
        </paragraph>

        <paragraph>
            To specify that a method offset needs to be adjusted depending on the passed in display pipe, the method offset is combined with DEVINIT_METHOD_USE_DPIPE using a logic OR.
            When the devinit engine sees a method offset with this bit set it masks out the bit and adjusts the base method offset to be correct for the display pipe that was specified when the engine was invoked.
            Under EVO designs, this means the passed in display pipe is multiplied by the proper amount and added to the base method offset.
        </paragraph>

        <paragraph>
            To specify that a opcode needs to be adjusted depending on the passed in DAC, SOR, or PIOR, the method offset is combined with DEVINIT_METHOD_USE_DAC, DEVINIT_METHOD_USE_SOR, or DEVINIT_METHOD_USE_PIOR using a logic OR.
            When the devinit engine sees a method offset with one of these bits it masks out the bit and adjusts the base method offset to be correct for the device that was specified when the engine was invoked.
            Under EVO designs, this means the passed in device is multiplied by the proper amount and added to the base method offset.
        </paragraph>

        <paragraph>
            The DEVINIT_METHOD_USE_DPIPE, DEVINIT_METHOD_USE_DAC, DEVINIT_METHOD_USE_SOR, and DEVINIT_METHOD_USE_PIOR bits are in the upper nibble of the 32-bit method offset, so they do not conflict with the address space of the method offsets themselves.
        </paragraph>

    </topic>

    <topic name="Deprecated Opcodes">
        <paragraph>
            There are a variety of opcodes that are no longer in use that are marked as deprecated.
            Deprecated opcodes are subject to be removed or redefined without further notice.
        </paragraph>
    </topic>


    <topic name="I/O Opcodes">
        <paragraph>
            All opcodes that deal with an I/O port may need to be adjusted according to the operating environment at the time of execution unless otherwise specified.
            For example, if the I/O port is specified as 0x3D4 and the controller is configured for monochrome operation, the port will be automatically adjusted to 0x3B4.
            This is also true of any of the CRTC opcodes, where the current I/O port address of the CRTC at the time the opcode is process is used.
            Implementations may need or wish to cache writes to the Miscellaneous Output Register (which controls the CRTC I/O port location) and simulate this operation.
        </paragraph>
        <paragraph>
            Unless otherwise noted, scripts and implementations of devinit engines shall not rely on scripts to preserve I/O register indexes.
            However, it is valid for implementations to preserve the indexes if it simplifies handling of the opcodes.
            Thus scripts can not rely on I/O indexes either being preserved or not preserved.
            Implementations are allowed to save and restore I/O register indexes even when no other operations are performed due to the condition flag state being set to skip operations.
        </paragraph>
        <paragraph>
            Devinit engines in platforms other than the VGA BIOS, such as the Resource Manager,
            usually need to convert I/O port operations into their equivalent privileged register operation.
            Please see "NVXX Display Class Priv Register Manual" (dev_disp.ref) for the proper mappings to use.
        </paragraph>
    </topic>

    <topic name="Attribute Controller Flip-Flop">
        <paragraph>
            Any devinit engines that use I/O ports directly must take into account the Attribute Controller flip-flop
            when Attribute Controller registers are specified by an instruction.
            This is required so that the index and data registers are accessed correctly.
            Devinit engines that convert I/O port accesses to privileged registers may need to simulate the Attribute Controller
            flip-flop depending on how the Attribute Controller registers are mapped to privileged registers on a given chip.
            While not required, it is acceptable to reset the Attribute Controller flip-flop even when other accesses are being skipped due to the state of the condition flag.
            It is also acceptable to reset the Attribute Controller flip-flop for all registers, not just Attribute Controller registers.
        </paragraph>
    </topic>

    <topic name="I2C Opcodes">
        <paragraph>
            For the I2C opcodes devinit engines may acquire the I2C port and prepare it for usage and shut it down and release it when it has finished processing the opcode,
            even when no I2C transactions are performed such as when the state of the condition flag is set to skip operations.
        </paragraph>
    </topic>


    <topic name="PLL ID defines">
        <paragraph>
            The PLL ID's are used to identify a PLL with a single byte instead of having to use the full 32-bit privileged registers address.
            These are standardized and used by the Resource Manager, they can not change (other than adding new ones, old ones are not reused).
        </paragraph>
        <paragraph>
            PLL ID's above 080h are assume to be in groups of 16.
            The lower nibble is stripped when the VGA BIOS searches the PLL lookup table for previous calculated coefficients,
            so all PLL's in a group need to have the same limit parameters for their PLL coefficient calculation.
        </paragraph>
        <paragraph>
            The PLL ID's defines are listed with the PLL Info Table specification in the "Core 6 Design Specification".
        </paragraph>
    </topic>


    <topic name="VGA Heads">
        <paragraph>
            For chips with two VGA heads (NV11-NV49), unless otherwise specified the opcodes all use the current CR44 head setting for reads and writes.
            If the CR44 head is not set earlier in the current script, the setting at the time the script is run is used.
            Note that chips G80 and beyond only have one VGA head (but have more than one display pipe).
        </paragraph>
    </topic>

    <topic name="Devinit Engine Interpreting">
        <paragraph>
            With very few exceptions, Devinit engines on different platforms must not attempt to "interpret" what a devinit script is doing in order to slightly modify the operations performed, unless absolutely necessary (starting with Core 6 VGA BIOS and FCODE images).
            Devinit engines must generally execute the operations specified by the devinit script verbatim.
            Doing this is very important in order to allow maintaining compatibility with future chips using existing drivers.
        </paragraph>
        <paragraph>
            Exceptions to this rule include conversion of I/O port opcodes to privileged registers in engines that cannot use I/O ports directly,
            tracking the location of the CRTC registers (0x3B4/0x3D4),
            and properly dealing with or simulating the attribute controller index/data flip-flop.
            Any other exceptions to this rule must be listed in this specification.
        </paragraph>
    </topic>

    <topic name="Sub scripts and the Condition Flag">
        <paragraph>
            Sub scripts, which are invoked with INIT_SUB/INIT_SUB_DIRECT, are typically implemented by starting a new Devinit Engine context. This new context would reset the Condition Flag. However, this is not the case in all engines:
        </paragraph>
        <paragraph>
            VBIOS CPU engine: INIT_SUB/INIT_SUB_DIRECT implicitly saves and restores the condition flag.
        </paragraph>

        <paragraph>
            VBIOS PMU engine: INIT_SUB/INIT_SUB_DIRECT implicitly saves and restores the condition flag.
        </paragraph>

        <paragraph>
            UEFI CPU engine: INIT_SUB/INIT_SUB_DIRECT implicitly saves and restores the condition flag.
        </paragraph>

        <paragraph>
            RM CPU engine: INIT_SUB/INIT_SUB_DIRECT re-uses the same context, so the condition flag is not saved/restored.
        </paragraph>
    </topic>

    <!-- *************** Opcodes *************** -->

    <opcode id="INIT_TIME" value="0x74" deprecated="false" conditionflag="honors">
        <summary>
            Delay a period of time in microsecond units.
        </summary>
        <details>
            <paragraph>
                This opcode causes the BIOS to delay processing for the number of microseconds specified in the delay value field.
            </paragraph>
            <paragraph>
                If the condition flag is set to the skip execution state, the time delay shall not occur.
            </paragraph>
            <note>
                Prior to core6, a delay of 0 invokes debugger (int1).
                This can be used as a devinit script "breakpoint".
                For core6 and beyond, use INIT_BREAK.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            All implementations prior to core6 ignore the condition flag.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="delays"        size="16"   description="Microsecond delay value"/>
        </layout>
    </opcode>

    <opcode id="INIT_TIME_MSEC" value="0x57" deprecated="false" conditionflag="honors">
        <summary>
            Delay a period of time in milliseconds.
        </summary>
        <details>
            <paragraph>
                This opcode causes the BIOS to delay processing for the number of milliseconds specified in the delay value field.
            </paragraph>
            <paragraph>
                If the condition flag is set to the skip execution state, the time delay shall not occur.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            All implementations prior to core6 ignore the condition flag.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="delays"        size="16"   description="Millisecond delay value"/>
        </layout>
    </opcode>

    <opcode id="INIT_NV_REG" value="0x6E" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a privileged register.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the specified privileged register.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using the OR mask.
                The resulting value is then written to the privileged register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="true"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="data"          size="32"   description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_NV_REG_UNCOUPLED" value="0x20" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a privileged register using a value from a passed in data buffer.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the specified privileged register.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using the 32-bit OR mask retrieved from the passed in data buffer.
                The resulting value is then written to the privileged register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_NV_REG_STREAM" value="0x10" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a privileged register using a value from a passed in data stream.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the specified privileged register.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using the 32-bit OR mask retrieved from the passed in data stream.
                The resulting value is then written to the privileged register.
            </paragraph>
            <paragraph>
                The number of bits the devinit engine will extract from the stream will be equal to the number of bits that are clear in the mask.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_NV_REG_READ" value="0x2C" deprecated="false" conditionflag="ignores">
        <summary>
            Read a privileged register.
        </summary>
        <details>
            <paragraph>
                This opcode reads the specified privileged register and stores the value read at an offset in the passed in data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_REG" value="0x7A" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to a privileged register (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode writes the data value to the specified privileged register without prior consideration to the previous value of the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Performs special handling for certain GPIO, PLL, power, and clock registers (needs to be removed for core6).
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="data"          size="32"   description="Data Value"/>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_REG_UNCOUPLED" value="0x21" deprecated="false" conditionflag="honors">
        <summary>
             Write a new value to a privileged register (zero mask) using a value from a passed in data buffer.
        </summary>
        <details>
            <paragraph>
                This opcode writes the data value to the specified privileged register without prior consideration to the previous value of the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_REG_STREAM" value="0x11" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to a privileged register (zero mask) using a value from a passed in data stream.
        </summary>
        <details>
            <paragraph>
                This opcode writes the data value to the specified privileged register without prior consideration to the previous value of the register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 32 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_NV_REG" value="0x48" deprecated="false" conditionflag="skipswrite">
        <summary>
            Sets specified bits in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "OR" operation with the specified data value, and writes the result back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="data"          size="32"   description="Data value"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_NV_REG_UNCOUPLED" value="0x22" deprecated="false" conditionflag="skipswrite">
        <summary>
            Sets bits specified by a value from a passed in data buffer in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "OR" operation with a value from the passed in data buffer, and writes the result back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_NV_REG_STREAM" value="0x12" deprecated="false" conditionflag="skipswrite">
        <summary>
            Sets bits specified by a value from a passed in data stream in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "OR" operation with a value from the passed in data stream, and writes the result back to the register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 32 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_NV_REG" value="0x47" deprecated="false" conditionflag="skipswrite">
        <summary>
            Resets specified bits in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "AND" operation with the complement of the specified data value, and writes the result back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="data"          size="32"   description="Data value"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_NV_REG_UNCOUPLED" value="0x23" deprecated="false" conditionflag="skipswrite">
        <summary>
            Resets bits specified by a value from a passed in data buffer in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "AND" operation with the complement of a value from the passed in data buffer, and writes the result back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_NV_REG_STREAM" value="0x13" deprecated="false" conditionflag="skipswrite">
        <summary>
            Resets bits specified by a value from a passed in data stream in a privileged register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified register, performs an "AND" operation with the complement of a value from the passed in data stream, and writes the result back to the register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 32 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_WREG" value="0x77" deprecated="true" conditionflag="honors">
        <summary>
            Write a new 16-bit value to a privileged register (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode writes the 16-bit data value to the specified privileged register without prior consideration to the previous value of the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-11-12" engine="VGA BIOS">
            Not implemented (deprecated).
        </audit>
        <audit date="2004-11-12" engine="Resource Manager">
            Performs special handling for certain GPIO, PLL, power, and clock registers (needs to be removed for core6).
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="data"          size="16"   description="Data value"/>
        </layout>
    </opcode>


    <opcode id="INIT_REG_ARRAY" value="0x58" deprecated="false" conditionflag="honors">
        <summary>
            Write a sequential block of privileged register with set of values.
        </summary>
        <details>
            <paragraph>
                This opcode writes a sequential set of data values to a sequential set of privileged registers.
                The privileged registers are assumed to be offset 4 bytes from each other.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="startreg"      size="32"   description="Start register address"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <array>
                <parameter name="data"         size="32"   description="Data Value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_ZM_REG_REITERATE" value="0x91" deprecated="false" conditionflag="honors">
        <summary>
            Write the same privileged register repeatedly with a sequence of data values.
        </summary>
        <details>
            <paragraph>
                This opcode writes a sequential set of data values to a single privileged register.
                This is usually used for programming blocks of indexed data registers where auto-incrementing of the index occurs.
                The initial index is usually written with a previous instruction such as INIT_ZM_REG.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core5r2"    supported="true"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2005-10-24" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2005-10-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2005-10-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <array>
                <parameter name="data"         size="32"   description="Data Value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_PLL" value="0x79" deprecated="true" conditionflag="honors">
        <summary>
            Program the specified PLL with a 16-bit frequency value.
        </summary>
        <details>
            <paragraph>
                This opcode will cause the indicated PLL to be programmed with a value that generates the specified clock frequency.
                The coefficients programmed into the PLL are calculated by the BIOS from the frequency, based on the chipset's PLL programming algorithm.
            </paragraph>
            <paragraph>
                The 16-bit frequency value is stored in kilohertz units (i.e.: 125Mhz = 12500).
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Ignores condition code.
        </audit>
        <layout>
            <parameter name="pllreg"        size="32"   description="PLL register"/>
            <parameter name="freq"          size="16"   description="Clock value (Mhz * 100)"/>
        </layout>
    </opcode>


    <opcode id="INIT_PLL32" value="0x4B" deprecated="true" conditionflag="honors">
        <summary>
            Program the specified PLL with a 32-bit frequency value.
        </summary>
        <details>
            <paragraph>
                This opcode will cause the indicated PLL to be programmed with a value that generates the specified clock frequency.
                The coefficients programmed into the PLL are calculated by the BIOS from the frequency, based on the chipset's PLL programming algorithm.
            </paragraph>
            <paragraph>
                The 32-bit frequency value is stored in kilohertz (i.e.: 125Mhz = 125000).
            </paragraph>
            <note>
                This opcode was actually added in core4r2, but first released in core5.
            </note>
            <note>
                Starting with core6 the opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Ignores condition code.
        </audit>
        <layout>
            <parameter name="pllreg"        size="32"   description="PLL register"/>
            <parameter name="freq"          size="32"   description="Clock value (kHz)"/>
        </layout>
    </opcode>


    <opcode id="INIT_PLLID" value="0x88" deprecated="false" conditionflag="honors">
        <summary>
            Program the PLL specified by a PLL ID with a 32-bit frequency value.
        </summary>
        <details>
            <paragraph>
                This opcode will cause the indicated PLL to be programmed with a value that generates the specified clock frequency.
                The coefficients programmed into the PLL are calculated by the BIOS from the frequency, based on the chipset's PLL programming algorithm.
            </paragraph>
            <paragraph>
                The PLL is specified by a PLLID.  The ID's are fixed defined values.
            </paragraph>
            <paragraph>
                The 32-bit frequency value is stored in kilohertz (i.e.: 125Mhz = 125000).
            </paragraph>
            <note>
                This opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-11-13" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="pllid"         size="8"    description="PLL ID"/>
            <parameter name="freq"          size="32"   description="Clock value (kHz)"/>
        </layout>
    </opcode>


    <opcode id="INIT_IO" value="0x69" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify an I/O port.
        </summary>
        <details>
            <paragraph>
                This opcode first reads a data value from the I/O port.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using the OR mask.
                The resulting value is then written back to the I/O port.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="I/O port"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="data"          size="8"    description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_IO_STREAM" value="0x1A" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify an I/O port using a value from a data stream.
        </summary>
        <details>
            <paragraph>
                This opcode first reads a data value from the I/O port.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using a value from a passed in data stream.
                The resulting value is then written back to the I/O port.
            </paragraph>
            <paragraph>
                The number of bits the devinit engine will extract from the stream will be equal to the number of bits that are clear in the mask.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="Indexed I/O port"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_IO" value="0x61" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to an I/O port (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode writes the specified value to the specified I/O port.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="I/O port to write"/>
            <parameter name="data"          size="8"    description="Data value"/>
        </layout>
    </opcode>

    <opcode id="INIT_INDEX_IO" value="0x78" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify an indexed I/O port.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the index register of the indexed I/O port (i.e.: 0x3D4) to select the indexed register to be written.
                It then reads a value from the data register of the indexed I/O port (i.e.: 0x3D5), performs a logical AND on the read value using the AND mask, then a logical OR on the value using the OR mask.
                The resulting value is then written back to the data register of the indexed I/O port.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.  No special handling is being performed for Attribute Controller registers.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.  No special handling is being performed for Attribute Controller registers.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="Indexed I/O port to write"/>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="data"          size="8"    description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_INDEX_IO_UNCOUPLED" value="0x25" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify an indexed I/O port using a value from a passed in data buffer.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the index register of the indexed I/O port (i.e.: 0x3D4) to select the indexed register to be written.
                It then reads a value from the data register of the indexed I/O port (i.e.: 0x3D5), performs a logical AND on the read value using the AND mask, then a logical OR on the value using a value from a passed in data buffer.
                The resulting value is then written back to the data register of the indexed I/O port.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_INDEX_IO_STREAM" value="0x15" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify an indexed I/O port using a value from a passed in data stream.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the index register of the indexed I/O port (i.e.: 0x3D4) to select the indexed register to be written.
                It then reads a value from the data register of the indexed I/O port (i.e.: 0x3D5), performs a logical AND on the read value using the AND mask, then a logical OR on the value using a value from a passed in data stream.
                The resulting value is then written back to the data register of the indexed I/O port.
            </paragraph>
            <paragraph>
                The number of bits the devinit engine will extract from the stream will be equal to the number of bits that are clear in the mask.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC" value="0x52" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a CRTC register.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then reads a value from the CRTC data register, performs a logical AND on the read value using the AND mask, then a logical OR on the value using the OR mask.
                The resulting value is then written back to the CRTC data register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="data"          size="8"    description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC_UNCOUPLED" value="0x24" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a CRTC register using a value from a passed in data buffer.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then reads a value from the CRTC data register, performs a logical AND on the read value using the AND mask, then a logical OR on the value using a value from a passed in data buffer.
                The resulting value is then written back to the CRTC data register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC_STREAM" value="0x14" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a CRTC register using a value from a passed in data stream.
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then reads a value from the CRTC data register, performs a logical AND on the read value using the AND mask, then a logical OR on the value using a value from a passed in data stream.
                The resulting value is then written back to the CRTC data register.
            </paragraph>
            <paragraph>
                The number of bits the devinit engine will extract from the stream will be equal to the number of bits that are clear in the mask.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_CRTC" value="0x84" deprecated="false" conditionflag="skipswrite">
        <summary>
            Set bits in a CRTC register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "OR" operation with the specified data value, and writes the result back to the CRTC register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="data"          size="8"    description="Data value"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_CRTC_UNCOUPLED" value="0x28" deprecated="false" conditionflag="skipswrite">
        <summary>
            Set bits in a CRTC register using a value from a passed in data buffer leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "OR" operation using a value from a passed in data buffer, and writes the result back to the CRTC register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBITS_CRTC_STREAM" value="0x18" deprecated="false" conditionflag="skipswrite">
        <summary>
            Set bits in a CRTC register using a value from a passed in data stream leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "OR" operation using a value from a passed in data stream, and writes the result back to the CRTC register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 8 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_CRTC" value="0x83" deprecated="false" conditionflag="skipswrite">
        <summary>
            Reset bits in a CRTC register leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "AND" operation with the complement of the specified data value, and writes the result back to the CRTC register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="data"          size="8"    description="Data value"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_CRTC_UNCOUPLED" value="0x29" deprecated="false" conditionflag="skipswrite">
        <summary>
            Reset bits in a CRTC register using a value from a passed in data buffer leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "AND" operation with the complement of a value from a passed in data buffer, and writes the result back to the CRTC register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBITS_CRTC_STREAM" value="0x19" deprecated="false" conditionflag="skipswrite">
        <summary>
            Reset bits in a CRTC register using a value from a passed in data stream leaving other bits unchanged.
        </summary>
        <details>
            <paragraph>
                This opcode reads the current value of the specified CRTC register, performs an "AND" operation with the complement of a value from a passed in data stream, and writes the result back to the CRTC register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 8 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC_READ" value="0x2D" deprecated="false" conditionflag="ignores">
        <summary>
            Read a CRTC register.
        </summary>
        <details>
            <paragraph>
                This opcode reads the specified CRTC register and stores the value read at an offset in the passed in data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC index"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC_READ_SPAN_STREAM" value="0x1B" deprecated="false" conditionflag="ignores">
        <summary>
            Read a span of CRTC registers and store the values in a byte stream.
        </summary>
        <details>
            <paragraph>
                This opcode reads sequential span of CRTC registers and stores the values read into the passed in data stream.
            </paragraph>
            <paragraph>
                The devinit engine will always insert 8 bits for each read CRTC register into the stream when processing this opcode.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="CRTC start index"/>
            <parameter name="count"         size="8"    description="Number of CRTC registers to read"/>
        </layout>
    </opcode>

    <opcode id="INIT_CRTC_SPAN_STREAM" value="0x1D" deprecated="false" conditionflag="honors">
        <summary>
            Write a span of CRTC registers with data from a byte stream.
        </summary>
        <details>
            <paragraph>
                This opcode writes a sequential span of CRTC registers using values from a passed in data stream.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 8 bits for each CRTC register from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final values from being written back to the registers.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="Start CRTC index"/>
            <parameter name="count"         size="8"    description="Number of CRTC registers to write"/>
        </layout>
    </opcode>

    <opcode id="INIT_POLL" value="0x55" deprecated="false" conditionflag="failsets">
        <summary>
            Poll an I/O port until a masked value compares correctly.
        </summary>
        <details>
            <paragraph>
                This opcode will poll an I/O port continually until a masked value results in a positive compare.
                This opcode uses the same table of conditions as the INIT_IO_CONDITION opcode.
            </paragraph>
            <paragraph>
                The timeout value sets the maximum amount of time this opcode will consume, and is not meant to control the sample rate for the terminating condition.
                This means that the mask/compare operation will usually occur at a higher rate than the delay value.
            </paragraph>
            <paragraph>
                If the poll is not satisfied and a timeout condition occurs the condition flag will be set to the skip execution state.
                Otherwise the condition flag is left in its current state from before the execution of the opcode.
                For this reason, it will often be necessary to follow this opcode with an INIT_RESUME if there is no need to know if the timeout occurred.
            </paragraph>
            <note>
                An index of 0xFF in the I/O condition table signals that a direct I/O port shall be used instead of an indexed I/O port.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <example>
            <line>BYTE  INIT_POLL</line>
            <line>BYTE  1       ; I/O Condition code</line>
            <line>BYTE  02h     ; 200 milliseconds max before continuing</line>
        </example>
        <layout>
            <parameter name="iocondition"   size="8"    description="I/O condition code"/>
            <parameter name="timeout"       size="8"    description="Timeout value (in 100 millisecond units)"/>
        </layout>
    </opcode>

    <opcode id="INIT_POLL_NV" value="0x56" deprecated="false" conditionflag="failsets">
        <summary>
            Poll a privileged register until a masked value compares correctly.
        </summary>
        <details>
            <paragraph>
                This opcode will poll a privileged register continually until a masked value results in a positive compare.
                This opcode uses the same table of conditions as the INIT_CONDITION opcode.
            </paragraph>
            <paragraph>
                The timeout value sets the maximum amount of time this opcode will consume, and is not meant to control the sample rate for the terminating condition.
                This means that the mask/compare operation will usually occur at a higher rate than the delay value.
            </paragraph>
            <paragraph>
                If the poll is not satisfied and a timeout condition occurs the condition flag will be set to the skip execution state.
                Otherwise the condition flag is left in its current state from before the execution of the opcode.
                For this reason, it will often be necessary to follow this opcode with an INIT_RESUME if there is no need to know if the timeout occurred.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <example>
            <description>
                This example will poll using condition code 1, and will not take more than 200 milliseconds before terminating.
            </description>
            <line>BYTE  INIT_POLL_NV</line>
            <line>BYTE  03h             ;Condition code to poll for</line>
            <line>BYTE  02h             ;200 milliseconds max before continuing</line>
        </example>
        <layout>
            <parameter name="condition"     size="8"    description="Condition code"/>
            <parameter name="timeout"       size="8"    description="Timeout value (in 100 milliseconds units)"/>
        </layout>
    </opcode>


    <opcode id="INIT_ZM_INDEX_IO" value="0x62" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to an indexed I/O port (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the index register of the indexed I/O port (i.e.: 0x3D4) to select the indexed register to be written.
                It then writes the data value to the data register of the indexed I/O port.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            No special handling is being performed for Attribute Controller registers.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            No special handling is being performed for Attribute Controller registers.
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="Indexed I/O port to write"/>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="data"          size="8"    description="Data value"/>
        </layout>
    </opcode>


    <opcode id="INIT_ZM_CRTC" value="0x53" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to a CRTC register (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then writes the data value to the CRTC data register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="data"          size="8"    description="Data value"/>
        </layout>
    </opcode>


    <opcode id="INIT_ZM_CRTC_UNCOUPLED" value="0x26" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to a CRTC register from a passed in data buffer (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then writes the data value from a passed in data buffer to the CRTC data register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>


    <opcode id="INIT_ZM_CRTC_STREAM" value="0x16" deprecated="false" conditionflag="honors">
        <summary>
            Write a new value to a CRTC register from a passed in data stream (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode first writes the register index to the CRTC index register to select the indexed register to be written.
                It then writes the data value from a passed in data stream to the CRTC data register.
            </paragraph>
            <paragraph>
                The devinit engine will always extract 8 bits from the stream for this opcode.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="index"         size="8"    description="Register index"/>
        </layout>
    </opcode>


    <opcode id="INIT_CRTC_ZM_ARRAY" value="0x54" deprecated="false" conditionflag="honors">
        <summary>
            Write a set values to a set of CRTC registers with no mask (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode writes a specified number of CRTC registers, with the index for each data value being specified.
                The register indexes can be specified randomly, they do not have to follow any particular sequence or order.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="count"         size="8"    description="Number of index/data pairs (N)"/>
            <array>
                <parameter name="index"         size="8"    description="Register index"/>
                <parameter name="data"          size="8"    description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_COPY" value="0x37" deprecated="false" conditionflag="skipswrite">
        <summary>
            Perform a copy from a privileged register to an indexed I/O port.
        </summary>
        <details>
            <paragraph>
                This opcode is used to copy data from a portion of a privileged register and copy it to an indexed I/O port.
                First a 32-bit value is read from the register at the specified privileged register.
                This value is then shifted using the 8-bit shift count.
                A positive shift count indicates a right shift, and a negative shift count (two's complement) indicates a left shift.
                An AND operation is then performed on this shifted value using the 8-bit source AND mask.
                Next, an 8-bit value is read from the specified indexed I/O port at the specified index.
                An AND operation is performed on this value with the 8-bit AND mask.
                Finally, an OR operation is performed using the this value and the value resulting from the AND with the 8-bit source AND mask.
                The result is then written back to the indexed I/O port.
            </paragraph>
            <note>
                S008shift can be negative (two's complement) for a left shift
            </note>
            <note>
                This opcode may eventually be deprecated, but currently full support exists in core6+ as of 2008-01-17.
            </note>
        </details>
        <todo>
            Once a data buffer is available for boot devinit scripts, this opcode will be replaced with the use of the read and logic opcodes.
        </todo>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <layout>
            <parameter name="reg"           size="32"   description="Register address"/>
            <parameter name="shift"         size="-8"   description="Shift count"/>
            <parameter name="smask"         size="8"    description="Source AND mask "/>
            <parameter name="port"          size="16"   description="I/O port to write"/>
            <parameter name="index"         size="8"    description="Register index"/>
            <parameter name="dmask"         size="8"    description="AND mask"/>
        </layout>
    </opcode>



    <opcode id="INIT_NV_COPY" value="0x5F" deprecated="false" conditionflag="skipswrite">
        <summary>
            Perform a copy from a privileged register to another privileged register.
        </summary>
        <details>
            <paragraph>
                This opcode is used to copy data from a portion of a privileged register to a different privileged register.
                First a value is read from the specified privileged register.
                This value is then shifted using the shift count.
                A positive shift count indicates a right shift, and a negative shift count (two's complement) indicates a left shift.
                An AND operation is then performed on this shifted value using the source AND mask.
                An XOR operation is then performed on the result of the AND operation and the XOR mask.
                Next, a value is read from the destination register address.
                An AND operation is performed on this value and the destination AND mask, with that result then used in an OR operation with the previous result of the XOR operation.
                The result is then written back to the destination register.
            </paragraph>
            <paragraph>
                Note that any of the following changes can be done to the individual bits of the destination register by using the specified values for the source AND mask and source XOR mask (for all four cases, the corresponding bit in the destination AND mask needs to be 0):
            </paragraph>
            <list>
                <item>
                    Direct copy from source register (AND mask bit = 1, XOR mask bit = 0)
                </item>
                <item>
                    Inverted copy from source register (AND mask bit = 1, XOR mask bit = 1)
                </item>
                <item>
                    Force bit to 0 (AND mask bit = 0, XOR mask bit = 0)
                </item>
                <item>
                    Force bit to 1 (AND mask bit = 0, XOR mask bit = 1)
                </item>
            </list>
            <paragraph>
                To preserve a bit in the destination register, the corresponding bit in the destination AND mask needs to be 1, and both the source AND mask and source XOR mask need to be zero.
            </paragraph>
            <note>
                S008shift can be negative (two's complement) for a left shift.
            </note>
            <note>
                This opcode may eventually be deprecated, but currently full support exists in core6+ as of 2008-01-17.
            </note>
        </details>
        <todo>
            Once a data buffer is available for boot devinit scripts, this opcode will be replaced with the use of the read and logic opcodes.
        </todo>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Source register address"/>
            <parameter name="shift"         size="8"   description="Shift count"/>
            <parameter name="andmask"       size="32"   description="Source AND mask "/>
            <parameter name="xormask"       size="32"   description="Source XOR mask "/>
            <parameter name="destaddr"      size="32"   description="Destination register address"/>
            <parameter name="destandmask"   size="32"   description="Destination AND mask"/>
        </layout>
    </opcode>


    <opcode id="INIT_DIRECT_COPY_NV_REG" value="0x90" deprecated="false" conditionflag="skipswrite">
        <summary>
            Perform a direct copy from a privileged register to another privileged register with no manipulation of the data value.
        </summary>
        <details>
            <paragraph>
                This opcode is used to copy data from a privileged register to a different privileged register.
                A value is read from the privileged register specified by the u032addr field.
                The value read is then written back to the destination register specified by u032destaddr.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core5r2"    supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-11-13" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-11-13" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2005-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Source register address"/>
            <parameter name="destaddr"      size="32"   description="Destination register address"/>
        </layout>
    </opcode>


    <opcode id="INIT_MEM_RESTRICT" value="0x6D" deprecated="true" conditionflag="failsets">
        <summary>
            Restrict processing according to memory configuration register
        </summary>
        <details>
            <paragraph>
                This opcode first reads a 32-bit value from the NV_PFB_BOOT_0 register and applies the logical AND mask to the lower 8 bits.
                The resulting value is compared to the comparison value.
                If the values do not match the condition flag is set to the skip operations state.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (deprecated).
        </audit>
        <layout>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="value"         size="8"    description="Comparison value"/>
        </layout>
    </opcode>



    <opcode id="INIT_STRAP_RESTRICT" value="0x73" deprecated="true" conditionflag="failsets">
        <summary>
            Restrict processing according to strap register contents.
        </summary>
        <details>
            <paragraph>
                This opcode first reads a value from the NV_PEXTDEV_BOOT_0 register and applies the logical AND mask to the value read.
                The resulting value is compared to the comparison value.
                If the values do not match the condition flag is set to the skip operations state.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (deprecated).
        </audit>
        <layout>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="value"         size="32"   description="Comparison value"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESUME" value="0x72" deprecated="false" conditionflag="clears">
        <summary>
            Used to end a block of script that was restricted due to a condition.
        </summary>
        <details>
            <paragraph>
                This opcode unconditionally sets the condition flag to the allow operations state so that following opcodes will be processed.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_NOT" value="0x38" deprecated="false" conditionflag="inverts">
        <summary>
            Perform NOT on the condition flag.
        </summary>
        <details>
            <paragraph>
                This opcode causes the current state of the condition flag to be inverted.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_RESET" value="0x65" deprecated="true" conditionflag="ignores">
        <summary>
            Toggle bits to perform a reset operation.
        </summary>
        <details>
            <paragraph>
                This opcode is used to toggle bits in a register to a disabled state, delay, and then back to an enabled state in order to perform a reset operation.
            </paragraph>
            <paragraph>
                As of core5, the VGA BIOS implementation of handler for this opcode saves the value of NV_PBUS_PCI_NV_19 and clears it to 0.
                It then sets the specified off state in NV_PMC_ENABLE, delays for 5 microseconds, and sets the on state in NV_PMC_ENABLE.
                Next it restores NV_PBUS_PCI_NV_19 and turns off NV_PBUS_PCI_NV_20_ROM_SHADOW_ENABLED in NV_PBUS_PCI_NV_20.
            </paragraph>
            <paragraph>
                The Resource Manager implementation disables SBA and AGP.
                For non-mobile NV17 boards it reads the value of NV_PMC_ENABLE, writes the off state to NV_PMC_ENABLE, delays for 1 millisecond,
                writes the on state to NV_PMC_ENABLE and reads NV_PMC_ENABLE two more times.
                For all other boards it writes the off state to NV_PMC_ENABLE and then writes the on state NV_PMC_ENABLE.
                Finally, for all boards the Resource Manager restores the AGP command register, disables ROM shadow, and reinitializes the timer.
            </paragraph>
            <paragraph>
                The FCode implementation differs in that it respects the condition flag.
                It disables AGP, SBA, and FW, writes the off state to NV_PMC_ENABLE, delays 5 microseconds, writes the on state to NV_PMC_ENABLE, restores the AGP Command register, and disables ROM shadow.
            </paragraph>
            <note>
                For core6 and beyond, the use of this opcode has been replaced with the use of other opcodes to perform the same operation.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is honoring the condition flag.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="value1"        size="32"   description="Off state to write to register address"/>
            <parameter name="value2"        size="32"   description="On state to write to register address"/>
        </layout>
    </opcode>


    <opcode id="INIT_SUB" value="0x6B" deprecated="false" conditionflag="honors">
        <summary>
            Execute another script and then return to process the current script.
        </summary>
        <details>
            <paragraph>
                The Script Table entry to be executed can be found by taking the script table index, multiplying by 2, and adding the result to the Script Table pointer.
            </paragraph>
            <paragraph>
                Control returns to the opcode immediately following the INIT_SUB after the sub script has been executed.
            </paragraph>
            <paragraph>
                In the VBIOS implementation of the devinit engine, the new script is executed by calling the devinit engine recursively.
            </paragraph>
            <note>
                If the condition flag is set to the skip operations state the subscript will not be executed.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="script"        size="8"    description="Script Table index"/>
        </layout>
    </opcode>


    <opcode id="INIT_JUMP" value="0x6A" deprecated="false" conditionflag="honors">
        <summary>
            Terminate execution of the current script and run a new one.
        </summary>
        <details>
            <paragraph>
                The Script Table entry to be executed can be found by taking the script table index, multiplying by 2, and adding the result to the Script Table pointer.
            </paragraph>
            <paragraph>
                This opcode ends processing of the current script, and begins execution of the new script.
                Control is not returned to the script containing the INIT_JUMP opcode.
            </paragraph>
            <note>
                If the condition flag is set to the skip operations state the jump will not be executed.
                In that case, there need to be valid opcodes following the INIT_JUMP opcode.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="script"        size="8"    description="Script Table index"/>
        </layout>
    </opcode>


    <opcode id="INIT_FUNCTION" value="0x35" deprecated="false" conditionflag="honors">
        <summary>
            Execute a generic function in the function table.
        </summary>
        <details>
            <paragraph>
                This opcode causes the code function specified by the index number to be executed.
                Following the return of the function, execution continues at the next opcode.
            </paragraph>
            <paragraph>
                Taking the function number, multiplying by 2, and adding the result to the Function Table Pointer base offset will find the location of the offset of the desired function.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="function"      size="8"    description="Function number"/>
        </layout>
    </opcode>


    <opcode id="INIT_MACRO" value="0x6F" deprecated="true" conditionflag="honors">
        <summary>
            Execute register macro array.
        </summary>
        <details>
            <paragraph>
                This opcode causes the specified macro sequence to be executed from the Macro Table.
                After completing the macro, execution will continue with the next opcode in the current script.
            </paragraph>
            <paragraph>
                Taking the macro index from the Macro Index Table, multiplying by 8, and adding the result to the Macro Table Pointer base offset will provide the start of the macro in the Macro Table.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="macro"         size="8"    description="Macro number"/>
        </layout>
    </opcode>


    <opcode id="INIT_CONDITION" value="0x75" deprecated="false" conditionflag="failsets">
        <summary>
            Restrict further processing based on a register condition.
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                Taking the condition number, multiplying by 12, and adding the result to the Condition Table Pointer base offset will find the start of the given condition.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is checking condition code on entry.
        </audit>
        <layout>
            <parameter name="condition"     size="8"    description="Condition number"/>
        </layout>
    </opcode>


    <opcode id="INIT_IO_CONDITION" value="0x76" deprecated="false" conditionflag="failsets">
        <summary>
            Restrict further processing based on an I/O condition.
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated I/O condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                Taking the condition number, multiplying by 5, and adding the result to the I/O Condition Table Pointer base offset will find the start of the given condition.
            </paragraph>
            <note>
                Starting with core5, an index of 0xFF in the I/O condition table signals that a direct I/O port shall be used instead of an indexed I/O port.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="modified"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is checking condition code on entry.
        </audit>
        <layout>
            <parameter name="iocondition"   size="8"    description="Condition number"/>
        </layout>
    </opcode>


    <opcode id="INIT_IO_FLAG_CONDITION" value="0x39" deprecated="false" conditionflag="failsets">
        <summary>
            Restrict further processing based on a flag in a flag array indexed by an I/O port value.
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated I/O flag condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                Taking the condition number, multiplying by 9, and adding the result to the I/O Flag Condition Table Pointer base offset will find the start of the given condition.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is forcing the condition code to allow operations on entry when it should be unmodified if condition succeeds.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is checking condition code on entry.
        </audit>
        <layout>
            <parameter name="ioflagcondition"     size="8"    description="I/O Flag Condition number"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESTRICT_PROG" value="0x31" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a privileged register with a value from an array chosen based on the value of another privileged register.
        </summary>
        <details>
            <paragraph>
                The first privileged register is read and the value read is masked with the specified AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to determine the value to write to the destination privileged register.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes will occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <example>
            <description>
                And example of writing a panel register, based on a strap field, would be:
            </description>
            <line>BYTE&#160;&#160;INIT_RESTRICT_PROG</line>
            <line>DWORD NV_PEXTDEV_BOOT_0&#160;; Base on strap register</line>
            <line>DWORD 0x03000000&#160;; AND mask for desired straps</line>
            <line>BYTE&#160;&#160;24&#160;; Shift count to make 0 based index</line>
            <line>BYTE&#160;&#160;4&#160;&#160;; Maximum values to select from</line>
            <line>DWORD NV_PRAMDAC_FP_DEBUG_0&#160;; Register to write with data</line>
            <line>DWORD 0x00000384&#160;; Data for strap index 0</line>
            <line>DWORD 0x0000037F&#160;; Data for strap index 1</line>
            <line>DWORD 0x00000383&#160;; Data for strap index 2</line>
            <line>DWORD 0x00000384&#160;; Data for strap index 3</line>
        </example>
        <layout>
            <parameter name="condAddr"      size="32"   description="Restricted register"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="addr"          size="32"   description="Destination privileged register"/>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_IO_RESTRICT_PROG" value="0x32" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a privileged register with a value from an array chosen based on the value of an indexed I/O port.
        </summary>
        <details>
            <paragraph>
                The indexed I/O register specified by the I/O port and index is read and the value read is masked with the specified AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to determine the value to write to the destination privileged register.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes will occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="port"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="addr"          size="32"   description="Privileged register"/>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_IO_RESTRICT_PROG_WM" value="0x59" deprecated="false" conditionflag="skipsrw">
        <summary>
            Modify a privileged register with a value from an array chosen based on the value of an indexed I/O port.
        </summary>
        <details>
            <paragraph>
                The indexed I/O register specified by the I/O port and index is read and the value read is masked with the specified source AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to determine the value to use to modify the destination privileged register.
            </paragraph>
            <paragraph>
                The destination privileged register is read and the resulting value is masked with the specified AND mask.
                An OR operation is performed between masked value and the value selected from the data array.
                The result is written back into the destination privileged register.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes will occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="port"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="Source AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="addr"          size="32"   description="Privileged register"/>
            <parameter name="andmask"       size="32"   description="AND mask"/>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_IO_RESTRICT_PLL" value="0x34" deprecated="true" conditionflag="skipswrite">
        <summary>
            Program a PLL with a frequency in a table indexed by the value in I/O port.
        </summary>
        <details>
            <paragraph>
                The indexed I/O register specified by the I/O port and index is read and the value read is masked with the specified AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to fetch the frequency value to program the PLL to.
            </paragraph>
            <paragraph>
                The frequency array is in 10 kHz units.
                If the specified doubling I/O flag condition is true, then the frequency will be doubled before being programmed.
                This is typically used for DDR memory.
            </paragraph>
            <paragraph>
                If the address of the PLL register to program is specified as 0, then no PLL programming will occur.
                This can be used as a placeholder for a future PLL register address.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final setting of the PLL.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final setting of the PLL.
        </audit>
        <layout>
            <parameter name="port"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="condition"     size="8"    description="Doubling I/O flag condition"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="addr"          size="16"   description="PLL register"/>
            <array>
                <parameter name="data"          size="16"   description="Frequency"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_IO_RESTRICT_PLL32" value="0x4A" deprecated="true" conditionflag="skipswrite">
        <summary>
            Program a PLL from a dword frequency array indexed by the value in I/O port.
        </summary>
        <details>
            <paragraph>
                The indexed I/O register specified by the I/O port and index is read and the value read is masked with the specified AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to fetch the frequency value to program the PLL to.
            </paragraph>
            <paragraph>
                The frequency array is in 1 kHz units.
            </paragraph>
            <paragraph>
                If the address of the PLL register to program is specified as 0, then no PLL programming will occur.
                This can be used as a placeholder for a future PLL register address.
            </paragraph>
            <note>
                This opcode was added in core4r2, but first released in core5.
            </note>
            <note>
                Starting with core6 the opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final setting of the PLL.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final setting of the PLL.
        </audit>
        <layout>
            <parameter name="port"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="addr"          size="32"   description="PLL register"/>
            <array>
                <parameter name="data"          size="32"   description="Frequency"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_IO_RESTRICT_PLLID" value="0x8A" deprecated="false" conditionflag="skipswrite">
        <summary>
            Program a PLL specified by a PLLID from a dword frequency array indexed by the value in I/O port.
        </summary>
        <details>
            <paragraph>
                The indexed I/O register specified by the I/O port and index is read and the value read is masked with the specified AND mask and shifted by the specified shift count.
                The resulting value is used as an index into the array of data values to fetch the frequency value to program the PLL to.
            </paragraph>
            <paragraph>
                The frequency array is in 1 kHz units.
            </paragraph>
            <paragraph>
                The PLL is specified by a PLLID.  The ID's are fixed defined values.
            </paragraph>
            <paragraph>
                If the ID of the PLL register to program is specified as 0, then no PLL programming will occur.
                This can be used as a placeholder for a future PLL register address.
            </paragraph>
            <note>
                This opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-08-09" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2005-08-09" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2005-08-09" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="port"          size="16"   description="Indexed I/O port"/>
            <parameter name="index"         size="8"    description="Indexed I/O index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="pllid"         size="8"    description="PLL ID"/>
            <array>
                <parameter name="data"          size="32"   description="Frequency"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_XMEMSEL_SCREEN_ZM_NV_REG" value="0x85" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a privileged register with a value from an array chosen based on the boards memory strap, with a bit screen to specify if the write should be allowed.
        </summary>
        <details>
            <paragraph>
                The VFIELDID_STRAP_MEMSEL virtual register field is used to obtain a memory strap value.
                The memory strap value is used as an index into the MemoryStrapTranslation array (pointed to by the BIT).
                The byte retrieved from the MemoryStrapTranslation is used as an index into the array of data values to retrieve the value to write to the destination privileged register.
            </paragraph>
            <paragraph>
                The translated value is also used to index into a bit screen (mask).
                If the selected bit is zero, the final write to the destination register shall be skipped.
                If the selected bit is one, the state of the condition flag determines if the final write to the destination register shall be skipped.
            </paragraph>
            <paragraph>
                The number of data values is specified by the MemoryStrapDataCount (located in the BIT).
                The number of bits used for the bit screen is determined by rounding MemoryStrapDataCount up to the next whole byte (8 screen bits per byte).
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes shall occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
            <paragraph>
                While the Resource Manager must use the VFIELDID_STRAP_MEMSEL virtual register field to obtain the memory strap,
                the VGA BIOS and Fcode implementations can optionally hard code the logic for obtaining the memory strap or use a different table to obtain it.
                This can be used to avoid requiring the VGA BIOS or Fcode implementations do processing of virtual fields.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="untested"/>
        </history>
        <audit date="2004-11-13" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Privileged register"/>
            <array>
                <parameter name="screen"        size="8"   description="Bit screen"/>
            </array>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_XMEMSEL_SCREEN_NV_REG" value="0x86" deprecated="false" conditionflag="skipswrite">
        <summary>
            Modify a privileged register using an AND mask and a value from an array chosen based on the boards memory strap, with a bit screen to specify if the write should be allowed.
        </summary>
        <details>
            <paragraph>
                The VFIELDID_STRAP_MEMSEL virtual register field is used to obtain a memory strap value.
                The memory strap value is used as an index into the MemoryStrapTranslation array (pointed to by the BIT).
                The byte retrieved from the MemoryStrapTranslation is used as an index into the array of data values to retrieve the value used to modify the destination privileged register.
                The engine reads the privileged register, and then performs a logical AND on the read value using the AND mask.
                It then does a logical OR on the value using the chosen value from the array of data values.
                The resulting value is then written back to the privileged register.
            </paragraph>
            <paragraph>
                The translated value is also used to index into a bit screen (mask).
                If the selected bit is zero, the final write to the destination register shall be skipped.
                If the selected bit is one, the state of the condition flag determines if the final write to the destination register shall be skipped.
            </paragraph>
            <paragraph>
                The number of data values is specified by the MemoryStrapDataCount (located in the BIT).
                The number of bits used for the bit screen is determined by rounding MemoryStrapDataCount up to the next whole byte (8 screen bits per byte).
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes shall occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
            <paragraph>
                While the Resource Manager must use the VFIELDID_STRAP_MEMSEL virtual register field to obtain the memory strap,
                the VGA BIOS and Fcode implementations can optionally hard code the logic for obtaining the memory strap or use a different table to obtain it.
                This can be used to avoid requiring the VGA BIOS or Fcode implementations do processing of virtual fields.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="untested"/>
        </history>
        <audit date="2004-11-13" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Privileged register"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <array>
                <parameter name="screen"        size="8"   description="Bit screen"/>
            </array>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_XMEMSEL_ZM_NV_REG_ARRAY" value="0x8F" deprecated="false" conditionflag="skipsarraywrite">
        <summary>
            Write a consecutive sequence of privileged registers with a block of values from a two dimensional array chosen based on the boards memory strap.
        </summary>
        <details>
            <paragraph>
                The VFIELDID_STRAP_MEMSEL virtual register field is used to obtain a memory strap value.
                The memory strap value is used as an index into the MemoryStrapTranslation array (pointed to by the BIT).
                <!--
                The byte retrieved from the MemoryStrapTranslation is multiplied by the count value in the instruction and used as a starting index into the array of data values.
                Consecutive privileged registers starting with the address specified with the instruction and continuing for the number of registers specified by the count are
                then written with the consecutive 32-bit values retrieved from the array starting at the computed starting index.
                -->
                The byte retrieved from the MemoryStrapTranslation is used as a starting index into the array of data values.
                The address specified in the instruction is used as the starting privileged register address.
                A 32-bit value retrieved from the array using the starting index is written to the privileged register.
                The privileged register address is advanced by the number of bytes specified by the stride and the index into the data values
                is advanced by adding the value of MemoryStrapDataCount (located in the BIT).
                This is repeated so that the total number of registers written is equal to the value of the count field in the instruction.
            </paragraph>
            <paragraph>
                The total number of data values in the array is computed by multiplying the count specified in the instruction by the value of MemoryStrapDataCount.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes shall occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
            <paragraph>
                While the Resource Manager must use the VFIELDID_STRAP_MEMSEL virtual register field to obtain the memory strap,
                the VGA BIOS and Fcode implementations can optionally hard code the logic for obtaining the memory strap or use a different table to obtain it.
                This can be used to avoid requiring the VGA BIOS or Fcode implementations do processing of virtual fields.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core5r2"    supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-11-13" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-11-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2005-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Starting privileged register"/>
            <parameter name="stride"        size="8"    description="Distance between privileged register addresses in bytes"/>
            <parameter name="count"         size="8"    description="Number of registers (not number of data values)"/>
            <array>
                <parameter name="data"          size="32"   description="Data value"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_XMEMSEL_PLLID" value="0x87" deprecated="false" conditionflag="skipswrite">
        <summary>
            Set a PLL with a frequency from an array chosen based on the boards memory strap.
        </summary>
        <details>
            <paragraph>
                The VFIELDID_STRAP_MEMSEL virtual register field is used to obtain a memory strap value.
                The memory strap value is used as an index into the MemoryStrapTranslation array (pointed to by the BIT).
                The byte retrieved from the MemoryStrapTranslation is used as an index into the array of frequencies to determine the frequency to program the specified PLL to.
                The coefficients programmed into the PLL are calculated by the BIOS from the frequency, based on the chipset's PLL programming algorithm.
            </paragraph>
            <paragraph>
                The 32-bit frequency value is stored in kilohertz (i.e.: 125Mhz = 125000).
            </paragraph>
            <paragraph>
                The PLL is specified by a PLLID.  The ID's are fixed defined values.
            </paragraph>
            <paragraph>
                The number of frequency values is specified by the MemoryStrapDataCount (located in the BIT).
            </paragraph>
            <paragraph>
                While the Resource Manager must use the VFIELDID_STRAP_MEMSEL virtual register field to obtain the memory strap,
                the VGA BIOS and Fcode implementations can optionally hard code the logic for obtaining the memory strap or use a different table to obtain it.
                This can be used to avoid having the VGA BIOS or Fcode implementations have to do virtual field processing.
            </paragraph>
            <note>
                This opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-11-13" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-11-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="pllid"          size="8"   description="PLL ID"/>
            <array>
                <parameter name="data"          size="32"   description="Frequency (1 kHz units)"/>
            </array>
        </layout>
    </opcode>


    <opcode id="INIT_REPEAT" value="0x33" deprecated="false" conditionflag="ignores">
        <summary>
            Repeat a block of script a specified number of times.
        </summary>
        <details>
            <paragraph>
                This opcode causes the following code, up to an INIT_END_REPEAT, to be executed a specified number of times.
            </paragraph>
            <note>
                Note that there must not be an INIT_DONE (or synonym) before the INIT_END_REPEAT code.
            </note>
            <note>
                The INIT_REPEAT opcode ignores the condition flag, but the codes being repeated will refer to or change the condition flag as they normally would.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="count"         size="8"    description="Repetition count"/>
        </layout>
    </opcode>


    <opcode id="INIT_DONE" value="0x71" deprecated="false" conditionflag="ignores">
        <summary>
            End of current script.
        </summary>
        <details>
            <paragraph>
                This opcode terminates the processing of the current script.
                For the boot scripts the devinit engine will continue processing with the next script in the Script Table.
            </paragraph>
            <note>
                If the condition flag is not reset via INIT_RESUME prior to INIT_DONE, correct operation is not guaranteed. See section on "Sub scripts and the Condition Flag."
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="EOL" value="0xFF" deprecated="true" conditionflag="ignores">
        <summary>
            NV1 opcode for the end of current script.
        </summary>
        <details>
            <paragraph>
                This opcode signifies the end of the current script.
                It was replaced by INIT_DONE.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="true"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_END_REPEAT" value="0x36" deprecated="false" conditionflag="ignores">
        <summary>
            Signal the end of a repeat block.
        </summary>
        <details>
            <paragraph>
                This opcode delimitates the end of a INIT_REPEAT block.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_SUB_DIRECT" value="0x5B" deprecated="false" conditionflag="honors">
        <summary>
            Execute another script (specified with a direct offset) and then return to process the current script.
        </summary>
        <details>
            <paragraph>
                Unlike INIT_SUB which uses a script index, this opcode has a direct offset to the sub script.
            </paragraph>
            <paragraph>
                Control returns to the opcode immediately following the INIT_SUB after the sub script has been executed.
            </paragraph>
            <paragraph>
                In the VBIOS implementation of the devinit engine, the new script is executed by calling the devinit engine recursively.
            </paragraph>
            <note>
                If the condition flag is set to the skip operations state the subscript will not be executed.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="offset"        size="16"   description="Script offset"/>
        </layout>
    </opcode>


    <opcode id="INIT_JUMP_DIRECT" value="0x5C" deprecated="false" conditionflag="honors">
        <summary>
            Terminate execution of the current script and run a new one (specified with a direct offset).
        </summary>
        <details>
            <paragraph>
                This opcode ends processing of the current script, and begins execution of the new script.
                Control is not returned to the script containing the INIT_JUMP opcode.
                Unlike INIT_JUMP which uses a script index, this opcode has a direct offset to the new script.
            </paragraph>
            <note>
                If the condition flag is set to the skip operations state the jump will not be executed.
                In that case, there need to be valid opcodes following the INIT_JUMP opcode.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="offset"        size="16"   description="Script offset"/>
        </layout>
    </opcode>


    <opcode id="INIT_JUMP_REL" value="0x89" deprecated="false" conditionflag="honors">
        <summary>
            Terminate execution of the current script and run a new one (specified relative to the current offset).
        </summary>
        <details>
            <paragraph>
                This opcode ends processing of the current script, and begins execution of the new script.
                Control is not returned to the script containing the INIT_JUMP opcode.
                This opcode uses a relative displacement from the current location to specify where to continue execution.
                The displacement is relative to the offset immediately after the displacement byte.
                The displacement is a signed two's complement value.
            </paragraph>
            <note>
                If the condition flag is set to the skip operations state the jump will not be executed.
                In that case, there need to be valid opcodes following the INIT_JUMP opcode.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="displacement"        size="8"   description="Relative displacement"/>
        </layout>
    </opcode>


    <opcode id="INIT_DONE_CONDITION" value="0x5D" deprecated="false" conditionflag="honors">
        <summary>
            Exit current script if conditions have been met.
        </summary>
        <details>
            <paragraph>
                This opcode terminates processing of the current script if the condition flag is set to the perform operations state.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_AUTOINC_I2CREG" value="0x4E" deprecated="false" conditionflag="honors">
        <summary>
            Write a sequence of new values to a sequence of I2C registers (zero mask). When count = 1, Sends I2C register byte address, without adding any effective write
        </summary>
        <details>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B, to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                For core4r2 the I2C port for external devices is always assumed to be I2C_C except on crush where it is I2C_D.
                So for core4r2 the current head does not need to be known.
                For core5 the DCB entry for the currently active device on the CR44 head is checked to see if the primary or secondary I2C port for external devices shall be used.
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core5 two other special values can also be used for the I2C Port Index.
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core6 another special value USE_DCB_DDC (0xFE) can also be used for the I2C Port Index, it uses the associated DCB entry's DDC port.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
            <note>
                Note that the count shall include the register address byte (RAB) and thus has to be one more than the number of data values following the RAB.
            </note>
            <paragraph>
                The devinit engine must not generate any I2C traffic when the condition code specifies that operations should be skipped.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index | USE_DCB_I2C (0xFF) | USE_DCB_DDC (0xFE) | USE_PRIMARY_I2C (0x80) | USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device Address"/>
            <parameter name="count"         size="8"    description="Number of entries including RAB (N+1)"/>
            <array>
                <parameter name="data"         size="8"    description="Data value"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_ALTERNATING_I2CREG" value="0x4D" deprecated="false" conditionflag="honors">
        <summary>
            Write a set of new values to a set of I2C registers (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode causes a given number of registers in a device to be written with specified values through a given I2C port.
            </paragraph>
            <paragraph>
                The designation 'alternating' refers to this opcode's ability to simulate the mode of some I2C devices which allows them to write several non-adjacent I2C registers in a single I2C message by concatenating {address, data} pairs (normally described as 'alternating write mode').
                This opcode simulates that ability by breaking the {address, data} pairs into separate I2C messages, with a full stop/start inserted between each pair.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                For core4r2 the I2C port for external devices is always assumed to be I2C_C except on crush where it is I2C_D.
                So for core4r2 the current head does not need to be known.
                For core5 the DCB entry for the currently active device on the CR44 head is checked to see if the primary or secondary I2C port for external devices shall be used.
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core5 two other special values can also be used for the I2C Port Index.
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core6 another special value USE_DCB_DDC (0xFE) can also be used for the I2C Port Index, it uses the associated DCB entry's DDC port.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
            <paragraph>
                The devinit engine must not generate any I2C traffic when the condition code specifies that operations should be skipped.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="count"         size="8"    description="Number of {address, data} pairs (N)"/>
            <array>
                <parameter name="index"         size="8"    description="Register address"/>
                <parameter name="data"          size="8"    description="Register data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_NV_ALTERNATING_I2CREG" value="0x4C" deprecated="false" conditionflag="honors">
        <summary>
            Read/modify/write an list of I2C register(s)
        </summary>
        <details>
            <paragraph>
                This opcode causes a specified set of registers in a device to be read, modified, and rewritten through a given I2C port.
            </paragraph>
            <paragraph>
                The designation 'alternating' refers to this opcode's ability to simulate the mode of some I2C devices which allows them to write several non-adjacent I2C registers in a single I2C message by concatenating {address, data} pairs (normally described as 'alternating write mode').
                This opcode simulates that ability by breaking the {address, data} pairs into separate I2C messages, with a full Stop/Start inserted between each pair.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                For core4r2 the I2C port for external devices is always assumed to be I2C_C except on crush where it is I2C_D.
                So for core4r2 the current head does not need to be known.
                For core5 the DCB entry for the currently active device on the CR44 head is checked to see if the primary or secondary I2C port for external devices shall be used.
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core6 another special value USE_DCB_DDC (0xFE) can also be used for the I2C Port Index, it uses the associated DCB entry's DDC port.
            </paragraph>
            <paragraph>
                For core5 two other special values can also be used for the I2C Port Index.
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
            <paragraph>
                The devinit engine must not generate any I2C traffic when the condition code specifies that operations should be skipped.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="count"         size="8"    description="Number of {address, AND mask, OR mask} sets (N)"/>
            <array>
                <parameter name="index"         size="8"    description="Register address"/>
                <parameter name="andmask"       size="8"    description="AND mask"/>
                <parameter name="ormask"        size="8"    description="OR mask"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_POLL_I2C" value="0x5A" deprecated="false" conditionflag="failsets">
        <summary>
            Poll an I2C register until a masked value compares correctly
        </summary>
        <details>
            <paragraph>
                This opcode will poll an I2C register continually until a masked value results in a positive compare.
            </paragraph>
            <paragraph>
                The timeout value sets the maximum amount of time this opcode will consume, and is not meant to control the sample rate for the terminating condition.
                This means that the mask/compare operation will usually occur at a higher rate than the delay value.
                Note that the units for this opcode are different than the other polling opcodes.
            </paragraph>
            <paragraph>
                If the poll is not satisfied and a timeout condition or an I2C read failure occurs the condition flag will be set to the skip operations state.
                Otherwise the condition flag is left in its current state from before the execution of the opcode.
                For this reason, it will often be desirable to follow this opcode with an INIT_RESUME if there is no need to know if the timeout occurred.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                For core4r2 the I2C port for external devices is always assumed to be I2C_C except on crush where it is I2C_D.
                So for core4r2 the current head does not need to be known.
                For core5 the DCB entry for the currently active device on the CR44 head is checked to see if the primary or secondary I2C port for external devices shall be used.
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core5 two other special values can also be used for the I2C Port Index.
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core6 another special value USE_DCB_DDC (0xFE) can also be used for the I2C Port Index, it uses the associated DCB entry's DDC port.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <example>
            <description>
                This example will poll register 0x04 from the device at address 0x70 on I2C port B.
                Bit 3 of the read value needs to be 0 and bit 2 needs to be a 1.
                The polling will not take more than 20 milliseconds before terminating.
            </description>
            <line>BYTE  INIT_POLL_I2C</line>
            <line>BYTE  02h             ; Use I2C port B as specified in the DCB</line>
            <line>BYTE  70h             ; Device address 0x70</line>
            <line>BYTE  04h             ; Register address 0x04</line>
            <line>BYTE  0Ch             ; AND mask</line>
            <line>BYTE  04h             ; Compare value</line>
            <line>BYTE  02h             ; 20 milliseconds max before continuing</line>
        </example>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="index"         size="8"    description="Register address"/>
            <parameter name="andmask"       size="8"    description="AND mask"/>
            <parameter name="compare"       size="8"    description="Compare value"/>
            <parameter name="timeout"       size="8"    description="Timeout value (in 10 milliseconds units)"/>
        </layout>
    </opcode>


    <opcode id="INIT_I2C_CONDITION" value="0x5E" deprecated="false" conditionflag="failsets">
        <summary>
            Check the condition of a register over I2C port
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated I2C condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met or an I2C read failure occurs the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                For core4r2 the I2C port for external devices is always assumed to be I2C_C except on crush where it is I2C_D.
                So for core4r2 the current head does not need to be known.
                For core5 the DCB entry for the currently active device on the CR44 head is checked to see if the primary or secondary I2C port for external devices shall be used.
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core5 two other special values can also be used for the I2C Port Index.
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                For core6 another special value USE_DCB_DDC (0xFE) can also be used for the I2C Port Index, it uses the associated DCB entry's DDC port.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <example>
            <description>
                This example will test register 0x04 from the device at address 0x70 on I2C port B.
                Bit 3 of the read value needs to be 0 and bit 2 needs to be a 1 for the condition to be considered met.
            </description>
            <line>BYTE  INIT_I2C_CONDITION</line>
            <line>BYTE  02h             ; Use I2C port B as specified in the DCB</line>
            <line>BYTE  70h             ; Device address 0x70</line>
            <line>BYTE  04h             ; Register address 0x04</line>
            <line>BYTE  0Ch             ; AND mask</line>
            <line>BYTE  04h             ; Compare value</line>
        </example>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="index"         size="8"    description="Register address"/>
            <parameter name="andmask"       size="8"    description="AND mask"/>
            <parameter name="compare"       size="8"    description="Compare value"/>
        </layout>
    </opcode>

    <opcode id="INIT_TMDS" value="0x4F" deprecated="true" conditionflag="honors">
        <summary>
            Performs read/modify/write on an internal TMDS/LVDS encoder link register.
        </summary>
        <details>
            <paragraph>
                This opcode reads a TMDS/LVDS encoder link register at the specified index on the specified link, masks the value with the specified AND mask, performs an OR operation with the specified OR mask, and write the result back to the register.
            </paragraph>
            <paragraph>
                The definition of the "link" field is as follows:
            </paragraph>
            <list>
                <item>
                    0 - link A
                </item>
                <item>
                    1 - link B
                </item>
                <item>
                    2 - link C
                </item>
                <item>
                    3 - link D
                </item>
                <item>
                    0x80 - "context" link
                </item>
                <item>
                    0x81 - "context" link's mate (link B if link A is the "context" link)
                </item>
            </list>
            <paragraph>
                Where "context" link is defined as the link that needs to be operated on.
                For the Resource Manager, the code will have complete knowledge of which this is.
            </paragraph>
            <paragraph>
                For the VBIOS the definition of the "context" link as follows:
            </paragraph>
            <list>
                <item>
                    1. Take the current value for CR44 to determine the "current" head.
                    (Note: While the VBIOS always leaves CR44 in broadcast mode for apps, internally it sets it to only the head its currently dealing with (enabling, disabling, changing DPMS level, etc.)
                </item>
                <item>
                    2. Use the scratch register to find what the current DCB index is for the current head (Note: Step 1 above is just conceptual, by just reading the scratch register, CR44 automatically directs us to the current head).
                </item>
                <item>
                    3. Use the link specified in the retrieved DCB entry
                </item>
            </list>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="link"          size="8"    description="Link"/>
            <parameter name="index"         size="8"    description="Index"/>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="data"          size="8"    description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_TMDS_ARRAY" value="0x50" deprecated="true" conditionflag="honors">
        <summary>
            Write a sequence of data values to an internal TMDS/LVDS encoder link.
        </summary>
        <details>
            <paragraph>
                This opcode writes the specified index/data pairs to the specified internal TMDS/LVDS encoder link.
            </paragraph>
            <paragraph>
                The definition of the "link" field is as follows:
            </paragraph>
            <list>
                <item>
                    0 - link A
                </item>
                <item>
                    1 - link B
                </item>
                <item>
                    2 - link C
                </item>
                <item>
                    3 - link D
                </item>
                <item>
                    0x80 - "context" link
                </item>
                <item>
                    0x81 - "context" link's mate (link B if link A is the "context" link)
                </item>
            </list>
            <paragraph>
                Where "context" link is defined as the link that needs to be operated on.
                For the Resource Manager, the code will have complete knowledge of which this is.
            </paragraph>
            <paragraph>
                For the VBIOS the definition of the "context" link as follows:
            </paragraph>
            <list>
                <item>
                    1. Take the current value for CR44 to determine the "current" head.  (Note: While the VBIOS always leaves CR44 in broadcast mode for apps, internally it sets it to only the head its currently dealing with (enabling, disabling, changing DPMS level, etc.)
                </item>
                <item>
                    2. Use the scratch register to find what the current DCB index is for the current head (Note: Step 1 above is just conceptual, by just reading the scratch register, CR44 automatically directs us to the current head).
                </item>
                <item>
                    3. Use the link specified in the retrieved DCB entry
                </item>
            </list>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="link"          size="8"    description="Link"/>
            <parameter name="count"         size="8"    description="Number of index/data pairs (N)"/>
            <array>
                <parameter name="index"         size="8"    description="Index"/>
                <parameter name="data"          size="8"    description="Data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_INDEXED_CRTC" value="0x51" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a set of indirectly indexed CRTC registers with constants.
        </summary>
        <details>
            <paragraph>
                This opcode will write a series of indirectly indexed CRTC registers.
            </paragraph>
            <paragraph>
                This opcode first writes the index register index to the CRTC base address (0x3D4 or 0x3B4) to select the 'CR space' of the bank of indirect CRTC registers (referred to as INDxx here) to access.
                It then writes the starting indirect index to the CRTC data register (0x3D5 or 0x3B5).
            </paragraph>
            <paragraph>
                The next step is to write the data register index to the CRTC base address (0x3D4 or 0x3B4) to allow access to the INDxx register of interest.
                It then writes the data1 value to the CRTC data register (0x3D5 or 0x3B5), effectively updating that INDxx register.
            </paragraph>
            <paragraph>
                This repeats for the number of INDxx registers specified by the count N.
            </paragraph>
            <paragraph>
                A two INDxx register example is given here.
                The example sets IND00 and IND01 to FFh.
            </paragraph>
            <paragraph>
                For clarity, the example is translated here as a series of DEBUG commands.
            </paragraph>
            <list>
                <item>
                        o 3d4 57    ;use color CRTC base address to select INDxx index
                </item>
                <item>
                        o 3d5 0     ;point at IND00
                </item>
                <item>
                        o 3d4 58    ;use color CRTC base address to select INDxx data
                </item>
                <item>
                        o 3d5 FF    ;update IND00 to FFh
                </item>
                <item>
                        o 3d4 57    ;use color CRTC base address to select INDxx index
                </item>
                <item>
                        o 3d5 1     ;point at IND01
                </item>
                <item>
                        o 3d4 58    ;use color CRTC base address to select INDxx data
                </item>
                <item>
                        o 3d5 FF    ;update IND01 to FFh
                </item>
            </list>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is skipping all register accesses, not just the final write.
        </audit>
        <example>
            <line>BYTE  INIT_INDEXED_CRTC</line>
            <line>BYTE  57h     ;CRTC INDxx index register</line>
            <line>BYTE  58h     ;CRTC INDxx data register</line>
            <line>BYTE  00h     ;starting INDxx index</line>
            <line>BYTE  02h     ;count</line>
            <line>BYTE  FFh     ;first data byte</line>
            <line>BYTE  FFh     ;second data byte</line>
        </example>
        <layout>
            <parameter name="indexreg"      size="8"    description="CRTC INDxx index register"/>
            <parameter name="datareg"       size="8"    description="CRTC INDxx data register"/>
            <parameter name="startindex"    size="8"    description="Starting INDxx index"/>
            <parameter name="count"         size="8"    description="Count (N)"/>
            <array>
                <parameter name="data"          size="8"    description="Data Value"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_AND" value="0x7B" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic AND operation on a dword in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 32-bit value at the specified byte offset into the data buffer is retrieved.
                An AND operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_OR" value="0x7C" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic OR operation on a dword in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 32-bit value at the specified byte offset into the data buffer is retrieved.
                An OR operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="32"   description="OR mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_XOR" value="0x7D" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic XOR operation on a dword in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 32-bit value at the specified byte offset into the data buffer is retrieved.
                An XOR operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="32"   description="XOR mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_SHIFT" value="0x7E" deprecated="false" conditionflag="honors">
        <summary>
            Perform a shift operation on a dword in the data buffer by a specified amount.
        </summary>
        <details>
            <paragraph>
                The 32-bit value at the specified byte offset into the data buffer is retrieved.
                The value is right shifted by the specified number of bits.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
            <note>
                S008shift can be negative (two's complement) for a left shift
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="shift"         size="8"   description="Number of bits to shift"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_AND_BYTE" value="0x7F" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic AND operation on a byte in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 8-bit value at the specified byte offset into the data buffer is retrieved.
                An AND operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <details>
            <paragraph>
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="8"    description="AND mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_OR_BYTE" value="0x80" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic OR operation on a byte in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 8-bit value at the specified byte offset into the data buffer is retrieved.
                An OR operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <details>
            <paragraph>
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="8"    description="OR mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_XOR_BYTE" value="0x81" deprecated="false" conditionflag="honors">
        <summary>
            Perform a logic XOR operation on a byte in the data buffer and a specified value.
        </summary>
        <details>
            <paragraph>
                The 8-bit value at the specified byte offset into the data buffer is retrieved.
                An XOR operation is performed between the retrieved value and the data value specified in the opcode.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="mask"          size="8"    description="XOR mask"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_SHIFT_BYTE" value="0x82" deprecated="false" conditionflag="honors">
        <summary>
            Perform a shift operation on a byte in the data buffer by a specified amount.
        </summary>
        <details>
            <paragraph>
                The 8-bit value at the specified byte offset into the data buffer is retrieved.
                The value is right shifted by the specified number of bits.
                The result is stored back at the specified byte offset into the data buffer.
            </paragraph>
            <note>
                S008shift can be negative (two's complement) for a left shift
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="shift"         size="-8"   description="Number of bits to shift"/>
            <parameter name="offset"        size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_SKIP_STREAM" value="0x1C" deprecated="false" conditionflag="ignores">
        <summary>
            Skip past the specified number of bits in the data stream.
        </summary>
        <details>
            <paragraph>
                The current position of the data stream is advanced by the specified number of bits.
                The stream can be advanced into the next byte or any following bytes.
            </paragraph>
            <note>
                S008data can be negative (two's complement) to go backward in the stream.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented yet.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented yet.
        </audit>
        <layout>
            <parameter name="data"          size="-8"   description="Number of bits to skip"/>
        </layout>
    </opcode>

    <opcode id="INIT_COMPUTE_MEM" value="0x63" deprecated="false" conditionflag="ignores">
        <summary>
            Forces a computation of the memory size.
        </summary>
        <details>
            <paragraph>
                This function forces the init processor to execute the chipset specific algorithm to compute the total frame buffer memory size installed.
            </paragraph>
            <paragraph>
                This opcode causes the BIOS function NVResizeMemory to be called.
                Upon return from the memory sizing routine, the devinit engine continues processing.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="true"/>
            <core name="nv4"        supported="true"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Engine is honoring the condition flag.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_MEM_INFO" value="0x9E" deprecated="false" conditionflag="ignores">
        <summary>
            Forces the Memory Information Table entry look-up.
        </summary>
        <details>
            <paragraph>
                This function forces the init processor to execute entry look-up in the Memory Information Table, which includes reading Memory Strap and/or Memory ID from hardware registers and searching for the matching entry.  The memory information is then cached for fast retrieval in subsequent operations.  Upon return from the Memory Information Table entry look-up, the devinit engine continues processing.
            </paragraph>
            <paragraph>
                This opcode allows for clear indication of when to read the Memory Strap and Memory ID registers, which may be manipulated by other devinit opcodes, so that all engines can be instructed to process the Memory Information Table in an identical sequence.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2008-12-09" engine="VGA BIOS">
            Not Implemented.
        </audit>
        <audit date="2008-12-09" engine="Resource Manager">
            Not Implemented.
        </audit>
        <audit date="2008-12-09" engine="FCode">
            Not Implemented.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_DAC_REG" value="0x64" deprecated="true" conditionflag="ignores">
        <summary>
            Write an NV1 DAC register after applying a mask.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the DAC register.
                It then performs a logical AND on the read value using the AND mask, then a logical OR on the value using the OR mask.
                The resulting value is then written to the specified register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="true"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-11-12" engine="VGA BIOS">
            Not implemented (deprecated).
        </audit>
        <layout>
            <parameter name="addr"          size="16"   description="DAC register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="data"          size="32"   description="OR mask"/>
        </layout>
    </opcode>

    <opcode id="INIT_CONFIGURE_MEM" value="0x66" deprecated="true" conditionflag="ignores">
        <summary>
            Configure Memory Registers (Skip to Next Table).
        </summary>
        <details>
            <paragraph>
                This function forces the initialization processor to execute the chipset specific algorithm to initialize the memory configuration registers using the memory configuration tables.
                This operation is performed before the memory sizing is performed.
            </paragraph>
            <paragraph>
                Prior to core3, the opcode would cause the devinit engine to call the hard coded memory initialization routine (NVConfigureMemory).
            </paragraph>
            <paragraph>
                This opcode was modified starting in core3 to instead terminate the current script, which would cause the execution of the following script in the POST Script Table to be executed.
            </paragraph>
            <note>
                Note: Compatibility with older drivers written for BIOS images before core3 is maintained by pointing the next sequential Script Table entry at the memory initialization script.
                The Script Table entry following the memory initialization script entry points back to the next opcode in the pre-core3 compatible devinit script.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="modified"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_CONFIGURE_CLK" value="0x67" deprecated="true" conditionflag="ignores">
        <summary>
        </summary>
        <details>
            <paragraph>
                This function forces the initialization processor to execute the chipset specific algorithm to initialize the memory PLL and NV PLL using the memory configuration tables.
            </paragraph>
            <paragraph>
                Prior to core3, the opcode would cause the devinit engine to call the hard coded memory initialization routine (NVConfigureClocks).
            </paragraph>
            <paragraph>
                This opcode was modified starting in core3 to instead terminate the current script, which would cause the execution of the following script in the POST Script Table to be executed.
            </paragraph>
            <note>
                Note: Compatibility with older drivers written for BIOS images before core3 is maintained by pointing the next sequential Script Table entry at the clock initialization script.
                The Script Table entry following the clock initialization script entry points back to the next opcode in the pre-core3 compatible devinit script.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="modified"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_CONFIGURE_PREINIT" value="0x68" deprecated="true" conditionflag="ignores">
        <summary>
            Configure initialization variables from HW strapping.
        </summary>
        <details>
            <paragraph>
                This function forces the initialization processor to execute the chipset specific algorithm to initialize certain scratch bits that indicate the strapped hardware configuration by way of reading the Strapping Register (NV_PEXTDEV_BOOT_0).
            </paragraph>
            <paragraph>
                The opcode initializes variables for the reference frequency (13Mhz vs. 14.318Mhz), and the RAM configuration straps.
            </paragraph>
            <paragraph>
                Prior to core3, the opcode would cause the devinit engine to call the hard coded initialization routine (ChipPreInit).
            </paragraph>
            <paragraph>
                This opcode was modified starting in core3 to instead terminate the current script, which would cause the execution of the following script in the POST Script Table to be executed.
            </paragraph>
            <note>
                Note: Compatibility with older drivers written for BIOS images before core3 is maintained by pointing the next sequential Script Table entry at the pre-initialization script.
                The Script Table entry following the pre-initialization script entry points back to the next opcode in the pre-core3 compatible devinit script.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="true"/>
            <core name="core3"      supported="modified"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_PLL_REG" value="0x70" deprecated="true" conditionflag="ignores">
        <summary>
            Set the NV1 DAC PLL synthesizer clock.
        </summary>
        <details>
            <paragraph>
                Programs the specified NV1 PLL with the specified coefficients.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="true"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-11-12" engine="VGA BIOS">
            Not implemented (deprecated).
        </audit>
        <layout>
            <parameter name="reg"               size="16"     description="DAC start address"/>
            <parameter name="m"                 size="8"      description="M PLL coefficient"/>
            <parameter name="n"                 size="8"      description="N PLL coefficient"/>
            <parameter name="o"                 size="8"      description="O PLL coefficient"/>
            <parameter name="p"                 size="8"      description="P PLL coefficient"/>
        </layout>
    </opcode>


    <opcode id="INIT_EOS" value="0x6C" deprecated="true" conditionflag="ignores">
        <summary>
            Signal end of the initialization script.
        </summary>
        <details>
            <paragraph>
                This opcode terminates the processing of the current script.
                For the boot scripts the devinit engine will continue processing with the next script in the Script Table.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_INDEX_ADDRESS_LATCHED" value="0x49" deprecated="true" conditionflag="honors">
        <summary>
            Write a sequence of data values to an address latched index register set.
        </summary>
        <details>
            <paragraph>
                This opcode retrieves the first data value and writes it to the data register.
                It then reads the control register and performs an AND operation on the value read and the control AND mask.
                An OR operation is done between the resulting value, the control OR mask, and the first index value.
                This value is then written back to the control register.
            </paragraph>
            <paragraph>
                This process is repeated for all the index/data pairs.
                The number of pairs is specified by the count value.
            </paragraph>
            <note>
                If the data register is specified as zero, the devinit engine must skip processing of this opcode.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="true"/>
            <core name="core4"      supported="true"/>
            <core name="core4r2"    supported="true"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-11-11" engine="VGA BIOS">
            The Core5 implementation is not checking for a data register address of zero.
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="controlreg"        size="32"   description="Control register"/>
            <parameter name="datareg"           size="32"   description="Data register"/>
            <parameter name="andmask"           size="32"   description="Control AND mask"/>
            <parameter name="writeormask"       size="32"   description="Control OR mask"/>
            <parameter name="count"             size="8"    description="Number of index/data pairs (N)"/>
            <array>
                <parameter name="index"             size="8"    description="Index"/>
                <parameter name="data"              size="8"    description="Data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_FREQ_CONDITION_XLAT_VFIELD" value="0xA0" deprecated="false" conditionflag="failsets">
        <summary>
            Test frequency condition.
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated frequency condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                Taking the PLL code, multiplying by 4, and adding the result to the PLL Register Table Pointer base offset will find the register address of the PLL coefficients to use for the test.
                The clock frequency is computed from these coefficients and then compared to the range.
                The range is specified in 10 kHz units.
                The range to use is first determined by using the virtual field code to access the virtual field table.
                The value from this register field is fetched.
                The value is then used as a byte index into the translation table referenced by the translation code.
                The value at that byte is then used as the index in the frequency array to determine which range to use.
            </paragraph>
        </details>
        <restriction>
            This opcode is only used in the full memory initialization sequence for the Resource Manager.
        </restriction>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="resman"/>
            <core name="core5"      supported="resman"/>
            <core name="core6"      supported="resman"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented (not needed at this time).
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (not needed at this time).
        </audit>
        <layout>
            <parameter name="vfield"        size="8"    description="Virtual field code"/>
            <parameter name="translation"   size="8"    description="Translation code"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="pllcode"       size="8"    description="PLL code"/>
            <array>
                <parameter name="lowfreq"       size="16"   description="Low frequency"/>
                <parameter name="highfreq"      size="16"   description="High frequency"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_RESTRICT_XLAT_VFIELD" value="0xA1" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a privileged register with a value from a table indexed by the translated value of field in another privileged register.
        </summary>
        <details>
            <paragraph>
                This opcode writes different values to a register based on a translated value.
                The virtual field code is used to access the virtual field table.
                The value from this register field is fetched.
                The value is then used as a byte index into the translation table referenced by the translation code.
                The value at that byte is then used as the index in the data array to determine which dword to use.
                The indicated register is read and an AND operation is performed using the AND mask.
                Finally, an OR operation is performed using the dword from the data array and the result is written back into the register.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes will occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
        </details>
        <restriction>
            This opcode is only used in the full memory initialization sequence for the Resource Manager.
        </restriction>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="resman"/>
            <core name="core5"      supported="resman"/>
            <core name="core6"      supported="resman"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented (not needed at this time).
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (not needed at this time).
        </audit>
        <layout>
            <parameter name="vfield"        size="8"    description="Virtual field code"/>
            <parameter name="translation"   size="8"    description="Translation code"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="reg"           size="32"   description="Privileged register"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <array>
                <parameter name="data"          size="32"   description="Data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_RESTRICT_XLAT_VFIELD_BYTE" value="0xA2" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a part of a privileged register with a value from a table indexed by the translated value of field in another register.
        </summary>
        <details>
            <paragraph>
                This opcode writes different values to a register based on a translated value.
                The virtual field code is used to access the virtual field table.
                The value from this register field is fetched.
                The value is then used as a byte index into the translation table referenced by the translation code.
                The value at that byte is then used as the index in the data array to determine which byte to use.
                The indicated register is read and an AND operation is performed using the AND mask.
                Finally, an OR operation is performed using the byte from the data array after it has been shifted by the indicated shift amount and the result is written back into the register.
            </paragraph>
            <paragraph>
                If the address of the privileged register to write is specified as 0, then no writes will occur.
                This can be used as a placeholder for a future register address.
            </paragraph>
        </details>
        <restriction>
            This opcode is only used in the full memory initialization sequence for the Resource Manager.
        </restriction>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="resman"/>
            <core name="core5"      supported="resman"/>
            <core name="core6"      supported="resman"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented (not needed at this time).
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (not needed at this time).
        </audit>
        <layout>
            <parameter name="vfield"        size="8"    description="Virtual field code"/>
            <parameter name="translation"   size="8"    description="Translation code"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="reg"           size="32"   description="Privileged register"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <array>
                <parameter name="data"          size="8"    description="Data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_RESTRICT_XLAT_VFIELD_PLL" value="0xA3" deprecated="true" conditionflag="skipswrite">
        <summary>
            Programs a PLL with a value from a table indexed by the translated value of field in another register.
        </summary>
        <details>
            <paragraph>
                This opcode programs different values to a PLL based on a translated value.
                The virtual field code is used to access the virtual field table.
                The value from this register field is fetched.
                The value is then used as a byte index into the translation table referenced by the translation code.
                The value at that byte is then used as the index in the data array to determine which frequency to use.
            </paragraph>
            <paragraph>
                If the address of the PLL register to program is specified as 0, then no PLL programming will occur.
                This can be used as a placeholder for a future PLL register address.
            </paragraph>
        </details>
        <restriction>
            This opcode is only used in the full memory initialization sequence for the Resource Manager.
        </restriction>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="resman"/>
            <core name="core5"      supported="resman"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented (not needed at this time).
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not checking to see if the PLL register to program is zero.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (not needed at this time).
        </audit>
        <layout>
            <parameter name="vfield"        size="8"    description="Virtual field code"/>
            <parameter name="translation"   size="8"    description="Translation code"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="pllcode"       size="8"    description="PLL code"/>
            <array>
                <parameter name="freq"          size="16"   description="Frequency"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_SPREAD" value="0x92" deprecated="true" conditionflag="ignores">
        <summary>
            Programs spread spectrum for all PLL's/clocks that have spread spectrum enabled, other than the pixel clocks.
        </summary>
        <details>
            <paragraph>
                This function causes all spread spectrum programming to occur for the system, other than pixel clocks.
                Processing of the opcode depends on the core and chip family, but for the most part involves checking the DCB to see if spread is enabled and what the settings are and programming those settings.
            </paragraph>
            <paragraph>
                Spread programming should be performed for both internal and external spread (which ever one is specified in the DCB).
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core5r2"    supported="true"/>
            <core name="core6"      supported="false"/>
        </history>
        <audit date="2005-11-4" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-11-4" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented.
        </audit>
        <layout>
        </layout>
    </opcode>


    <opcode id="INIT_ADD_NV_REG" value="0x97" deprecated="false" conditionflag="skipswrite">
        <summary>
            Add a delta to current value of a privileged register with mask.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the specified privileged register.
                It then adds the add value to the value read.
                Next it performs a logical AND on the resulting sum using the bitwise inverse of the AND mask to mask out any overflow.
                A logical AND on the original value read using the AND mask (not inverted) is then performed.
                The results of the two AND operations are then combined with a logical OR operation.
                The result from the final OR operation is then written to the privileged register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="true"/>
        </history>
        <audit date="2007-12-12" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-01-17" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2008-01-17" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="add"           size="32"   description="Add value"/>
        </layout>
    </opcode>

    <opcode id="INIT_DPCD_REG" value="0x98" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write DPCD registers with mask.
        </summary>
        <details>
            <paragraph>
                This opcode first reads the specified DPCD registers, and with AND mask, then or with the data.
                The result is then written to the DPCD registers.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="true"/>
        </history>
        <audit date="2008-03-12" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-03-12" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2008-03-12" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="DPCD address"/>
            <parameter name="count"         size="8"    description="Number of entries"/>
            <array>
                <parameter name="mask"          size="8"    description="AND mask"/>
                <parameter name="data"          size="8"    description="data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_ZM_DPCD_REG" value="0x99" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write DPCD registers.
        </summary>
        <details>
            <paragraph>
                This opcode writes the specified DPCD registers.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="true"/>
        </history>
        <audit date="2008-03-12" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-03-12" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2008-03-12" engine="FCode">
            Code in compliance.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="DPCD address"/>
            <parameter name="count"         size="8"    description="Number of entries"/>
            <array>
                <parameter name="data"          size="8"    description="data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="POLL_DPCD_REG" value="0xA6" deprecated="false" conditionflag="skipswrite">
        <summary>
            Poll DPCD register until a masked value compares correctly
        </summary>
        <details>
            <paragraph>
                This opcode will poll a DPCD register continually until a masked value results in a positive compare.
            </paragraph>
            <paragraph>
                The timeout value sets the maximum amount of time this opcode will consume, and is not meant to control the sample rate for the terminating condition.
                This means that the mask/compare operation will usually occur at a higher rate than the delay value.
            </paragraph>
            <paragraph>
                If the poll is not satisfied and a timeout condition or a DPCD read failure occurs the condition flag will be set to the skip operations state.
                Otherwise the condition flag is left in its current state from before the execution of the opcode.
                For this reason, it will often be desirable to follow this opcode with an INIT_RESUME if there is no need to know if the timeout occurred.
            </paragraph>
        </details>

        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core75"     supported="true"/>
        </history>
        <audit date="2009-09-17" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2009-09-17" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2009-09-17" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="DPCD address"/>
            <parameter name="andmask"       size="8"    description="AND mask"/>
            <parameter name="compare"       size="8"    description="Compare value"/>
            <parameter name="timeout"       size="8"    description="Timeout value (in 1 milliseconds units)"/>
        </layout>
    </opcode>

    <opcode id="INIT_DPCD_CONDITION" value="0xA7" deprecated="false" conditionflag="skipswrite">
        <summary>
            Check the condition of a DPCD register
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated DPCD condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met or a DPCD read failure occurs the condition flag is set to the skip operations state.
            </paragraph>
        </details>

        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core75"     supported="true"/>
        </history>
        <audit date="2009-09-17" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2009-09-17" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2009-09-17" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="DPCD address"/>
            <parameter name="andmask"       size="8"    description="AND mask"/>
            <parameter name="compare"       size="8"    description="Compare value"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESTRICT_XLAT_VFIELD_PLL32" value="0xA4" deprecated="false" conditionflag="skipswrite">
        <summary>
            Programs a PLL with a frequency from a table indexed by the translated value of field in another register.
        </summary>
        <details>
            <paragraph>
                This opcode programs different values to a PLL based on a translated value.
                The virtual field code is used to access the virtual field table.
                The value from this register field is fetched.
                The value is then used as a byte index into the translation table referenced by the translation code.
                The value at that byte is then used as the index in the data array to determine which frequency to use.
            </paragraph>
            <paragraph>
                If the address of the PLL register to program is specified as 0, then no PLL programming will occur.
                This can be used as a placeholder for a future PLL register address.
            </paragraph>
            <note>
                Starting with core6 the opcode only updates the coefficients and does not configure or enable the PLL.
            </note>
        </details>
        <restriction>
            This opcode is only used in the full memory initialization sequence for the Resource Manager.
        </restriction>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="resman"/>
        </history>
        <audit date="2004-09-15" engine="VGA BIOS">
            Not implemented (not needed at this time).
        </audit>
        <audit date="2004-09-15" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-15" engine="FCode">
            Not implemented (not needed at this time).
        </audit>
        <layout>
            <parameter name="vfield"        size="8"    description="Virtual field code"/>
            <parameter name="translation"   size="8"    description="Translation code"/>
            <parameter name="count"         size="8"    description="Number of entries (N)"/>
            <parameter name="pllcode"       size="8"    description="PLL code"/>
            <array>
                <parameter name="freq"          size="32"   description="Frequency (1 kHz units)"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_INDEX_BYTE_ARRAY_NV_REG" value="0x96" deprecated="false" conditionflag="skipswrite">
        <summary>
            Write a part of a privileged register with a value from a table indexed by the value of field in another privileged register.
        </summary>
        <details>
            <paragraph>
                First a 32-bit value is read from the register at the specified privileged register (source register).
                This value is then right shifted using the 8-bit shift count.
                An AND operation is then performed on this shifted value using the 8-bit source AND mask.
                The resulting value, the data array offset, is then used as an index into a data array of bytes to get the value to write into the destination privileged register.
                The data array to use is indicated by the data array table index.
                The data array table index is an index into a table of word pointers to data arrays.
                The base address of the data array pointer table (referred to as the table of word pointers above) is in the VBIOS BIT (DataArraysTablePtr in the BIT_NVINIT_PTRS structure).
                The destination register is read and an AND operation is performed using the AND mask.
                The value retrieved from the data array is shifted left by the indicated shift amount and then ORed with the the result of the AND operation in the previous step.
                The resulting value is written back into the destination register.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="true"/>
        </history>
        <audit date="2007-09-20" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2004-09-20" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2004-09-20" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Source register address"/>
            <parameter name="shift"         size="8"    description="Shift count"/>
            <parameter name="andmask"       size="8"    description="Source AND mask"/>
            <parameter name="dataarraytableindex"     size="8"    description="Data array table index"/>
            <parameter name="destaddr"      size="32"   description="Destination register address"/>
            <parameter name="destandmask"   size="32"   description="Destination AND mask"/>
            <parameter name="destshift"     size="8"    description="Retrieved data array value shift count"/>
        </layout>
    </opcode>

    <opcode id="INIT_BREAK" value="0x8B" deprecated="false" conditionflag="honors">
        <summary>
            Cause a breakpoint to be triggered while processing the devinit script.
        </summary>
        <details>
            <paragraph>
                This opcode causes the BIOS to assert an INT1 to invoke the debugger.  This can be used as a devinit script "breakpoint".
            </paragraph>
            <note>
                This opcode must never appear in production code.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-09-21" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-09-21" engine="Resource Manager">
            Not currently supported.
        </audit>
        <audit date="2005-09-21" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_RESET_BEGUN" value="0x8C" deprecated="false" conditionflag="ignores">
        <summary>
            Signal that the reset sequence has begun.
        </summary>
        <details>
            <paragraph>
                This opcode signals that the software reset sequence has begun.
                Ordinarily, no actual operations are performed by the opcode.
                However it allows for possible software work arounds by devinit engines in software agents other than the VBIOS, such as the resman, FCODE, and EFI driver.
                This opcode is designed to be included in the devinit script immediately after the NV_PMC_ENABLE register has be written to put most engines into a reset state.
            </paragraph>
            <note>
                In general, performing operations when encountering this opcode should be avoided.
                Ideally any new operations needed should be communicated back to the VGA BIOS team so that they can be listed explicitly in the devinit sequence.
                The reason for this is that these work arounds can interfere with forward compatibility.
                However, this opcode exists for those cases where embedding the operations in the devinit sequence is not possible or practical
                (such as work arounds for VGA BIOS images that have already shipped).
            </note>
            <note>
                Any operations performed when this opcode is processed must be documented here in this specification to make
                sure these operations are taken into account for future devinit scripts.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-09-22" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-09-22" engine="Resource Manager">
            Not currently supported.
        </audit>
        <audit date="2005-09-22" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_RESET_END" value="0x8D" deprecated="false" conditionflag="ignores">
        <summary>
            Signal that the reset sequence has completed.
        </summary>
        <details>
            <paragraph>
                This opcode signals that the software reset sequence has completed.
                Ordinarily, no actual operations are performed by the opcode.
                However it allows for possible software work arounds by devinit engines in software agents other than the VBIOS, such as the resman, FCODE, and EFI driver.
                This opcode is designed to be included in the devinit script immediately after the NV_PMC_ENABLE register has be written to take most of the engines out of the reset state.
            </paragraph>
            <note>
                In general, performing operations when encountering this opcode should be avoided.
                Ideally any new operations needed should be communicated back to the VGA BIOS team so that they can be listed explicitly in the devinit sequence.
                The reason for this is that these work arounds can interfere with forward compatibility.
                However, this opcode exists for those cases where embedding the operations in the devinit sequence is not possible or practical
                (such as work arounds for VGA BIOS images that have already shipped).
            </note>
            <note>
                Any operations performed when this opcode is processed must be documented here in this specification to make
                sure these operations are taken into account for future devinit scripts.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2005-09-22" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2005-09-22" engine="Resource Manager">
            Not currently supported.
        </audit>
        <audit date="2005-09-22" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_GPIO_ALL" value="0x8E" deprecated="false" conditionflag="honors">
        <summary>
            Configure all GPIO's based on the DCB GPIO Assignment Table.
        </summary>
        <details>
            <paragraph>
                This opcode causes the devinit engine to process the DCB GPIO Assignment Table and initialize
                the output enable and output level for each listed GPIO to the state specified by the "init" bit in each entry.
                The normal, sequencer, alternate setting for each GPIO listed is also configured.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2012-06-11" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2012-06-11" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2005-09-28" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_GPIO_EXCLUDE_ARRAY" value="0xA9" deprecated="false" conditionflag="honors">
        <summary>
            Initialize all GPIOs less a specified set of GPIOs by function, based on the DCB GPIO Assignment Table.
        </summary>
        <details>
            <paragraph>
                This opcode is similar to INIT_GPIO_ALL, except that it lists an array of GPIO functions to be excluded from initialization.
                It can only be called once in devinit.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core75"     supported="false"/>
            <core name="core80"     supported="true"/>
        </history>
        <audit date="2012-06-11" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2012-06-11" engine="Resource Manager">
            Code in compliance.
        </audit>
        <audit date="2012-06-11" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
            <parameter name="count"         size="8"    description="Number of function in array (N)"/>
            <array>
                <parameter name="function"     size="8"   description="GPIO Function"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_GPIO_INCLUDE_ARRAY" value="0xA8" deprecated="false" conditionflag="honors">
        <summary>
            Initialize a specified set of GPIOs by function, based on the DCB GPIO Assignment Table.
        </summary>
        <details>
            <paragraph>
                This opcode is similar to INIT_GPIO_ALL, except that it lists an array of GPIO functions to be initialized.
                It can be called multiple times in devinit.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core75"     supported="false"/>
            <core name="core80"     supported="true"/>
        </history>
        <audit date="2012-06-11" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2012-06-11" engine="Resource Manager">
            Not currently supported.
        </audit>
        <audit date="2012-06-11" engine="FCode">
            Not currently supported.
        </audit>
        <layout>
            <parameter name="count"         size="8"    description="Number of function in array (N)"/>
            <array>
                <parameter name="function"     size="8"   description="GPIO Function"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_DISPLAY_METHOD" value="0x95" deprecated="false" conditionflag="skipswrite">
        <summary>
            Invoke a dipslay class method.
        </summary>
        <details>
            <paragraph>
                This opcode executes a display class method.
                See the following documents for information about display methods:
            </paragraph>
            <list>
                <item>
                    \\hw\nv5x\class\mfs\class\disp\dispClass_01.mfs,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_software_interface.doc,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_driver_vbios_switching.doc
                </item>
            </list>
            <paragraph>
                This opcode is usually not used and is never included in scripts visible to the resman.
            </paragraph>
            <note>
                This opcode is called INIT_METHOD_507D in the EFI source code, but plans are to update that.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2006-10-30" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2006-10-30" engine="Resource Manager">
            Code not present.  Should remain that way for now.
        </audit>
        <audit date="2006-10-30" engine="EFI">
            Code in compliance, but name of opcode incorrect.
        </audit>
        <layout>
            <parameter name="offset"        size="32"   description="Method offset"/>
            <parameter name="data"          size="32"   description="Method data"/>
        </layout>
    </opcode>

    <opcode id="INIT_DISPLAY_METHOD_UNCOUPLED" value="0x2E" deprecated="false" conditionflag="skipswrite">
        <summary>
            Invoke a dipslay class method using a data value from a passed in data buffer.
        </summary>
        <details>
            <paragraph>
                This opcode executes a display class method.
                See the following documents for information about display methods:
            </paragraph>
            <list>
                <item>
                    \\hw\nv5x\class\mfs\class\disp\dispClass_01.mfs,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_software_interface.doc,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_driver_vbios_switching.doc
                </item>
            </list>
            <paragraph>
                This opcode is usually not used and is never included in scripts visible to the resman.
            </paragraph>
            <note>
                This opcode is called INIT_METHOD_507D_UNCOUPLED in the EFI source code, but plans are to update that.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2006-10-30" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2006-10-30" engine="Resource Manager">
            Code not present.  Should remain that way for now.
        </audit>
        <audit date="2006-10-30" engine="EFI">
            Code in compliance, but name of opcode incorrect.
        </audit>
        <layout>
            <parameter name="offset"        size="32"   description="Method offset"/>
            <parameter name="data"          size="8"    description="Data buffer offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_DISPLAY_METHOD_STREAM" value="0x1E" deprecated="false" conditionflag="skipswrite">
        <summary>
            Invoke a dipslay class method using a data value a passed in data stream.
        </summary>
        <details>
            <paragraph>
                This opcode executes a display class method.
                See the following documents for information about display methods:
            </paragraph>
            <list>
                <item>
                    \\hw\nv5x\class\mfs\class\disp\dispClass_01.mfs,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_software_interface.doc,
                </item>
                <item>
                    \\hw\nv5x\doc\nv50\iso\specifications\display\display_driver_vbios_switching.doc
                </item>
            </list>
            <paragraph>
                This opcode is usually not used and is never included in scripts visible to the resman.
            </paragraph>
            <paragraph>
                The devinit engine will extract 32-bits from the stream.
                The bits must be extracted even when the condition code state prevents the final value from being written back to the register.
            </paragraph>
            <note>
                This opcode is called INIT_METHOD_507D_STREAM in the EFI source code, but plans are to update that.
            </note>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="true"/>
        </history>
        <audit date="2006-10-30" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2006-10-30" engine="Resource Manager">
            Code not present.  Should remain that way for now.
        </audit>
        <audit date="2006-10-30" engine="EFI">
            Code in compliance, but name of opcode incorrect.
        </audit>
        <layout>
            <parameter name="offset"        size="32"   description="Method offset"/>
        </layout>
    </opcode>

    <opcode id="INIT_GENERIC_CONDITION" value="0x3A" deprecated="false" conditionflag="ignores">
        <summary>
            Restrict further processing based on a generic condition with a condition ID.
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                Condition ID:
                    <item>CONDITION_ID_INT_DP  = 0x00: condition is met if it is internal DP(i.e. requires sequencer control).</item>
                    <item>CONDITION_ID_USE_SPPLL0 = 0x01: condition is met if DP uses SPPLL0.</item>
                    <item>CONDITION_ID_USE_SPPLL1 = 0x02: condition is met if DP uses SPPLL1.</item>
                    <item>(0x3 and 0x4 are reserved for future expansion if we are going to have more SPPLLs.)</item>
                    <item>CONDITION_ID_ASSR_SUPPORT = 0x05: condition is met if DP panel supports ASSR(eDP).</item>
                    <item>CONDITION_ID_FINISH_VCO_CAL_IN_DEVINIT = 0x06: condition is met if the final steps of TMDS VCO calibration should be handled in the devinit script.</item>
                    <item>CONDITION_ID_NO_PANEL_SEQ_DELAYS = 0x07: This condition is true when the panel is in self refresh or if RM has setup a flag to capture supervisor script
                          or for other modes for which we are sure that the panel will not be powered down and doesnt need sequencing. When this condition is true, we run
                          the IED Script with no delays (sor_lvds_Init_Sequencer_nd) and if this condition is false, we run the normal script which has delays (sor_lvds_Init_Sequencer).</item>
                    <item>CONDITION_INVALID = 0xFF: we could override condition ID to _INVALID, in effect to skip this condition.</item>
            </paragraph>
            <paragraph>
                Condition length field is added in an effort to make smooth synchronization between vbios and driver changes.
                When new condition ID is added, if code(vbios/driver/efi) doesn't support it yet, it should skip
                condition_length bytes, and continue to process the next devinit token.
            </paragraph>

        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2008-11-24" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-11-24" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2008-11-24" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="condition_id"      size="8"    description="condition ID"/>
            <parameter name="condition_length"  size="8"    description="number of bytes in condition block"/>
        </layout>
    </opcode>

    <opcode id="INIT_RESETBIT_CRTC_OUTDEV" value="0x3B" deprecated="false" conditionflag="ignores">
        <summary>
            Resets CR register bit based on OUTDEV, e.g. resets bit0 if it is SOR0.
        </summary>
        <details>
            <paragraph>
                This opcode resets bitx if it is OUTDEVx.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2008-12-02" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-12-02" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2008-12-02" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="cr_index"      size="8"    description="cr register index"/>
        </layout>
    </opcode>

    <opcode id="INIT_SETBIT_CRTC_OUTDEV" value="0x3C" deprecated="false" conditionflag="ignores">
        <summary>
            Sets CR register bit based on OUTDEV, e.g. sets bit0 if it is SOR0.
        </summary>
        <details>
            <paragraph>
                This opcode sets bitx if it is OUTDEVx.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2008-12-02" engine="VGA BIOS">
            Code in compliance.
        </audit>
        <audit date="2008-12-02" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2008-12-02" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="cr_index"      size="8"    description="cr register index"/>
        </layout>
    </opcode>

    <opcode id="INIT_OBTAIN_HW_MUTEX" value="0x9B" deprecated="false" conditionflag="failsets">
        <summary>
            Attempts to obtain a PMU hardware mutex
        </summary>
        <details>
            <paragraph>
                This opcode attempts to obtain a hardware mutex specified by the PMU architecture. The code will make
                multiple attempts over several milliseconds. Number and time to be determined through testing.
            </paragraph>
            <paragraph>
                Mutex values 1-3 are reserved for vbios. When run by vbios, this opcode will use a value of 2.
                Operations will be skipped if the mutex is currently held by vbios.
            </paragraph>
            <paragraph>
                When run by RM, the normal process of obtaining a mutex value through the NEXT_AVAIL_MUTEX_ID register
                should be followed.
            </paragraph>
            <paragraph>
                Be careful when using this opcode within a condition block. Operations will be skipped if the condition
                flag is set, but this opcode can also set the condition flag if the mutex is not obtained.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2009-03-18" engine="VGA BIOS">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="addr"      size="32"    description="mutex address"/>
        </layout>
    </opcode>

    <opcode id="INIT_RELEASE_HW_MUTEX" value="0x9C" deprecated="false" conditionflag="honors">
        <summary>
            Releases a PMU hardware mutex
        </summary>
        <details>
            <paragraph>
                This opcode releases a hardware mutex obtained with INIT_OBTAIN_HW_MUTEX. The write will only be
                performed if the mutex is held by the party executing the command (VBIOS or RM).
            </paragraph>
            <paragraph>
                As this opcode honors the condition flag which is set by INIT_OBTAIN_HW_MUTEX, it should be followed by
                INIT_RESUME in most cases.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2009-03-18" engine="VGA BIOS">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="addr"      size="32"    description="mutex address"/>
        </layout>
    </opcode>

    <opcode id="INIT_EXEC_PMU_ROUTINE" value="0x9D" deprecated="false" conditionflag="honors">
        <summary>
            Executes a specified PMU routine
        </summary>
        <details>
            <paragraph>
                This opcode executes a PMU routine through the PBI (post-box interface). It can be modeled by this
                sequence:
            </paragraph>
            <list>
                <item>INIT_HW_OBTAIN_MUTEX pbi</item>
                <item>INIT_ZM_REG pbi_data_in, param</item>
                <item>INIT_ZM_REG pbi_ctrl, exec_routine</item>
                <item>INIT_HW_RELEASE_MUTEX pbi</item>
                <item>INIT_RESUME</item>
            </list>
            <paragraph>
                The exception to this sequence is that this opcode honors the condition flag and does not affect it.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2009-03-18" engine="VGA BIOS">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="Resource Manager">
            Code not present.
        </audit>
        <audit date="2009-03-18" engine="EFI">
            Code not present.
        </audit>
        <layout>
            <parameter name="param"        size="32"   description="(31:8) optional routine parameter, (7:0) routine ID"/>
        </layout>
    </opcode>


    <opcode id="INIT_I2C16_CONDITION" value="0x9A" deprecated="false" conditionflag="failsets">
        <summary>
            Check the condition of a register over 16-bit I2C port
        </summary>
        <details>
            <paragraph>
                This opcode performs the same functions as INIT_I2C_CONDITION, but for I2C devices that use 16-bit register addressing.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="true"/>
        </history>
        <audit date="2009-07-13" engine="VGA BIOS">
            Not audited.
        </audit>
        <audit date="2009-07-13" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2009-07-13" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="index"         size="16"   description="Register address"/>
            <parameter name="andmask"       size="8"    description="AND mask"/>
            <parameter name="compare"       size="8"    description="Compare value"/>
        </layout>
    </opcode>

    <opcode id="INIT_VDT" value="0xAA" deprecated="false" conditionflag="failsets">
        <summary>
            Set NVVDD depending on the VDT entry
        </summary>
        <details>
            <paragraph>
                This opcode invokes the PMU to set the NVVDD depending on the VDT table entry that is passed.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="true"/>
        </history>
        <audit date="2012-08-22" engine="VGA BIOS">
            Audited.
        </audit>
        <audit date="2012-08-22" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2012-08-22" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="VDTEntry"      size="8"    description="VDT Table Entry index which is used for setting NVVDD"/>
            <parameter name="temperature"   size="16"   description="Signed fixed point value (SFXP11.5) of the temperature that is used to calculate the voltage. This parameter is reserved for future versions of voltage calculations."/>
        </layout>
    </opcode>

    <opcode id="INIT_NOP" value="0xAB" deprecated="false" conditionflag="ignores">
        <summary>
            No operation
        </summary>
        <details>
            <paragraph>
                This opcode does nothing and used to increment the current script offset.
                This opcode is primarily used to replace existing opcodes in devinit WAR infrastructure.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="true"/>
            <core name="core84"     supported="true"/>
        </history>
        <audit date="2014-01-24" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2014-01-24" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2014-01-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2014-01-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_NV_REG_CONDITION_DIRECT" value="0xAC" deprecated="false" conditionflag="failsets">
        <summary>
            Restrict further processing based on a register condition.
        </summary>
        <details>
            <paragraph>
                This opcode reads the specified priveleged register. It then performs a logical AND operation on the read value using the AND MASK provided. It then compares this result to the value field.
                If the value field matches the result, condition flag is unmodified.
                If the value field doesn't match the result, condition flag is set to skip operations state.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="true"/>
            <core name="core84"     supported="true"/>
        </history>
        <audit date="2014-01-24" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2014-01-24" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2014-01-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2014-01-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="addr"          size="32"   description="Register address"/>
            <parameter name="mask"          size="32"   description="AND mask"/>
            <parameter name="data"          size="32"   description="Compare value"/>
        </layout>
    </opcode>

    <opcode id="INIT_NV_PRIVLEVEL_DOWNGRADE" value="0xAD" deprecated="false" conditionflag="failsets">
        <summary>
            Reduce the privilege level of the EXT transaction.
        </summary>
        <details>
            <paragraph>
                This opcode is used to reduce the privilege level to 0. Please note that we only lower the PRIV level only for the transaction and not the actual priv level.
                This opcode is primarily used in the devinit WAR binary before OVERWRITE and INSERT operations.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="true"/>
        </history>
        <audit date="2014-04-24" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2014-04-24" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2014-04-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2014-04-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
        </layout>
    </opcode>

    <opcode id="INIT_NV_PRIVLEVEL_RESTORE" value="0xAE" deprecated="false" conditionflag="failsets">
        <summary>
            Restore the privilege level of the EXT transaction
        </summary>
        <details>
            <paragraph>
                This opcode is used to restore the privilege level to 3. Please note that we only restore the PRIV level only for the transaction and not the actual priv level.
                This opcode is primarily used in the devinit WAR binary after OVERWRITE and INSERT operations.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="true"/>
        </history>
        <audit date="2014-04-24" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2014-04-24" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2014-04-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2014-04-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
        </layout>
    </opcode>
    <opcode id="INIT_NV_REG_ARRAY_REITERATE" value="0xAF" deprecated="false" conditionflag="failsets">
        <summary>
            Write a set of privileged registers repeatedly with different sequences of data values.
        </summary>
        <details>
            <paragraph>
                This opcode writes different blocks of values into a set of privileged registers. This opcode provides scope of space optimizations
                where a particular set of registers needs to be written with different set of values multiple times.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="false"/>
            <core name="core86"     supported="true"/>
        </history>
        <audit date="2014-04-24" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2014-04-24" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2014-04-24" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2014-04-24" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="reiterate"  size="8"   description="This field determines the number of times the given set of registers must be written with different set of values. "/>
            <parameter name="count"   size="8"   description="This field determines the count of registers in the specified set."/>
            <array>
                <parameter name="addr"      size="32"    description="register address"/>
                <parameter name="data"          size="32"    description="data"/>
            </array>
        </layout>
    </opcode>
    <opcode id="INIT_TSOSC" value="0xB0" deprecated="false" conditionflag="failsets">
        <summary>
            Calculates and sets up TSOSC temperature coefficients.
        </summary>
        <details>
            <paragraph>
                Temperature Sensing OSCillators (TSOSCs) require various coefficients for calibration.
                This opcode reads calibration values from fuses as parameters, calculates the needed coefficients, and programs them.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="false"/>
            <core name="core86"     supported="false"/>
            <core name="core88"     supported="true"/>
        </history>
        <audit date="2016-10-06" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2016-10-06" engine="VGA BIOS">
            Not implemented
        </audit>
        <audit date="2016-10-06" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2016-10-06" engine="FCode">
            Not implemented.
        </audit>
        <layout>
        </layout>
    </opcode>
    <opcode id="INIT_POLL_NV_COND" value="0xB1" deprecated="false" conditionflag="honors">
        <summary>
            Poll a privileged register until a masked value compares correctly, only if surrounding INIT_CONDITION is true.
        </summary>
        <details>
            <paragraph>
                This opcode does the same routine as INIT_POLL_NV after checking for prior register condition in INIT_CONDITION, skips the polling process if the prior condition is not met.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="false"/>
            <core name="core86"     supported="false"/>
            <core name="core88"     supported="true"/>
        </history>
        <audit date="2017-1-10" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2017-1-10" engine="VGA BIOS">
            Code in compliance
        </audit>
        <audit date="2017-1-10" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2017-1-10" engine="FCode">
            Not implemented.
        </audit>
        <example>
            <description>
                If INIT_CONDITION just before INIT_POLL_NV_COND is met, this example will poll using condition code 1, and will not take more than 200 milliseconds before terminating, else will skip the polling process.
            </description>
            <line>BYTE  INIT_POLL_NV_COND</line>
            <line>BYTE  03h             ;Condition code to poll for</line>
            <line>BYTE  02h             ;200 milliseconds max before continuing</line>
        </example>
        <layout>
            <parameter name="condition"     size="8"    description="Condition code"/>
            <parameter name="timeout"       size="8"    description="Timeout value (in 100 milliseconds units)"/>
        </layout>
    </opcode>
    <opcode id="INIT_ZM_ALTERNATING16_I2CREG" value="0xB3" deprecated="false" conditionflag="honors">
        <summary>
            Write a set of new word values to a set of I2C registers (zero mask).
        </summary>
        <details>
            <paragraph>
                This opcode causes a given number of registers in a device to be written with specified values through a given I2C port.
            </paragraph>
            <paragraph>
                The designation 'alternating' refers to this opcode's ability to simulate the mode of some I2C devices which allows them to write several non-adjacent I2C registers in a single I2C message by concatenating {address, data} pairs (normally described as 'alternating write mode').
                This opcode simulates that ability by breaking the {address, data} pairs into separate I2C messages, with a full stop/start inserted between each pair.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                The primary and secondary ports are specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                USE_PRIMARY_I2C uses the primary port and USE_SECONDARY_I2C uses the secondary port as specified in the DCB I2C Control Block.
            </paragraph>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
            <paragraph>
                The devinit engine must not generate any I2C traffic when the condition code specifies that operations should be skipped.
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="false"/>
            <core name="core86"     supported="true"/>
        </history>
        <audit date="2017-03-16" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2017-03-16" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2017-03-16" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2017-03-16" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="count"         size="8"    description="Number of {address, data} pairs (N) where data is word"/>
            <array>
                <parameter name="index"         size="8"    description="Register address"/>
                <parameter name="data"          size="16"    description="2-byte Register data"/>
            </array>
        </layout>
    </opcode>

    <opcode id="INIT_I2C_WORD_CONDITION" value="0xB4" deprecated="false" conditionflag="failsets">
        <summary>
            Check the condition of a register with 16bit data over I2C port
        </summary>
        <details>
            <paragraph>
                This opcode causes the indicated I2C condition to be tested.
                If the condition is met the condition flag is unmodified.
                If the condition is not met or an I2C read failure occurs the condition flag is set to the skip operations state.
            </paragraph>
            <paragraph>
                The I2C Port Index uses the same equates normally used in the VBIOS, i.e. I2C_A, I2C_B,  to indicate the first and second logical I2C ports, respectively.
                Alternatively, USE_DCB_I2C (0xFF) will force the usage of the logical I2C port index associated with the currently active display for programming external devices, a per-head value.
                Internally, the VBIOS uses the DCB index scratch register field for the current head to find the I2C port specified by the DCB entry.
                This assumes:
            </paragraph>
            <list>
                <item>
                    1. When this opcode is called, the VBIOS is NOT in broadcast mode
                </item>
                <item>
                    2. The DCB index for the head the VBIOS is on is either a valid DCB index or EMPTY_HEAD
                </item>
                <item>
                    3. If the DCB index is EMPTY_HEAD the opcode processing will be skipped (essentially, making this opcode a no-op)
                </item>
            </list>
            <paragraph>
                The device address specifies the I2C address of the device to initialize via the selected I2C port (e.g. SI178 uses 0x70, CX871 uses 0x88).
            </paragraph>
        </details>
        <history>
            <core name="nv1"        supported="false"/>
            <core name="nv3"        supported="false"/>
            <core name="nv4"        supported="false"/>
            <core name="nv5"        supported="false"/>
            <core name="core3"      supported="false"/>
            <core name="core4"      supported="false"/>
            <core name="core4r2"    supported="false"/>
            <core name="core5"      supported="false"/>
            <core name="core6"      supported="false"/>
            <core name="core6r2"    supported="false"/>
            <core name="core70"     supported="false"/>
            <core name="core80"     supported="false"/>
            <core name="core82"     supported="false"/>
            <core name="core84"     supported="false"/>
            <core name="core86"     supported="false"/>
            <core name="core88"     supported="true"/>
        </history>
         <audit date="2017-03-16" engine="PMU Devinit Engine">
            Code in compliance
        </audit>
        <audit date="2017-03-16" engine="VGA BIOS">
            Not implemented.
        </audit>
        <audit date="2017-03-16" engine="Resource Manager">
            Not implemented.
        </audit>
        <audit date="2017-03-16" engine="FCode">
            Not implemented.
        </audit>
        <layout>
            <parameter name="I2CIndex"      size="8"    description="DCB.I2C port index or USE_DCB_I2C (0xFF) or USE_DCB_DDC (0xFE) or USE_PRIMARY_I2C (0x80) or USE_SECONDARY_I2C (0x81)"/>
            <parameter name="SubAddress"    size="8"    description="Device address"/>
            <parameter name="index"         size="8"    description="Register address"/>
            <parameter name="andmask"       size="16"   description="AND mask, 2 bytes long"/>
            <parameter name="compare"       size="16"   description="Compare value, 2 bytes long"/>
        </layout>
    </opcode>
</devinit_spec>
